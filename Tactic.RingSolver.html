<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--without-K</a> <a id="296" class="Pragma">--safe</a> <a id="303" class="Symbol">#-}</a>

<a id="308" class="Keyword">module</a> <a id="315" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="333" class="Keyword">where</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Agda.Builtin.Reflection.html" class="Module">Agda.Builtin.Reflection</a>

<a id="377" class="Keyword">open</a> <a id="382" class="Keyword">import</a> <a id="389" href="Algebra.html" class="Module">Algebra</a>
<a id="397" class="Keyword">open</a> <a id="402" class="Keyword">import</a> <a id="409" href="Data.Fin.html" class="Module">Data.Fin</a>   <a id="420" class="Symbol">as</a> <a id="423" class="Module">Fin</a>   <a id="429" class="Keyword">using</a> <a id="435" class="Symbol">(</a><a id="436" href="Data.Fin.Base.html#1066" class="Datatype">Fin</a><a id="439" class="Symbol">)</a>
<a id="441" class="Keyword">open</a> <a id="446" class="Keyword">import</a> <a id="453" href="Data.Vec.html" class="Module">Data.Vec</a>   <a id="464" class="Symbol">as</a> <a id="467" class="Module">Vec</a>   <a id="473" class="Keyword">using</a> <a id="479" class="Symbol">(</a><a id="480" href="Data.Vec.Base.html#959" class="Datatype">Vec</a><a id="483" class="Symbol">;</a> <a id="485" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">_∷_</a><a id="488" class="Symbol">;</a> <a id="490" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="492" class="Symbol">)</a>
<a id="494" class="Keyword">open</a> <a id="499" class="Keyword">import</a> <a id="506" href="Data.List.html" class="Module">Data.List</a>  <a id="517" class="Symbol">as</a> <a id="520" class="Module">List</a>  <a id="526" class="Keyword">using</a> <a id="532" class="Symbol">(</a><a id="533" href="Agda.Builtin.List.html#121" class="Datatype">List</a><a id="537" class="Symbol">;</a> <a id="539" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">_∷_</a><a id="542" class="Symbol">;</a> <a id="544" href="Data.List.Base.html#9701" class="InductiveConstructor">[]</a><a id="546" class="Symbol">)</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="576" class="Symbol">as</a> <a id="579" class="Module">Maybe</a> <a id="585" class="Keyword">using</a> <a id="591" class="Symbol">(</a><a id="592" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a><a id="597" class="Symbol">;</a> <a id="599" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a><a id="603" class="Symbol">;</a> <a id="605" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a><a id="612" class="Symbol">;</a> <a id="614" href="Data.Maybe.Base.html#1651" class="Function">fromMaybe</a><a id="623" class="Symbol">)</a>
<a id="625" class="Keyword">open</a> <a id="630" class="Keyword">import</a> <a id="637" href="Data.Nat.html" class="Module">Data.Nat</a>            <a id="657" class="Keyword">using</a> <a id="663" class="Symbol">(</a><a id="664" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="665" class="Symbol">;</a> <a id="667" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="670" class="Symbol">;</a> <a id="672" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="676" class="Symbol">;</a> <a id="678" href="Agda.Builtin.Nat.html#719" class="Primitive Operator">_&lt;ᵇ_</a><a id="682" class="Symbol">)</a>
<a id="684" class="Keyword">open</a> <a id="689" class="Keyword">import</a> <a id="696" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a> <a id="716" class="Keyword">using</a> <a id="722" class="Symbol">(</a><a id="723" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a><a id="729" class="Symbol">;</a> <a id="731" href="Data.Nat.Reflection.html#637" class="Function">toFinTerm</a><a id="740" class="Symbol">)</a>
<a id="742" class="Keyword">open</a> <a id="747" class="Keyword">import</a> <a id="754" href="Data.Bool.html" class="Module">Data.Bool</a>           <a id="774" class="Keyword">using</a> <a id="780" class="Symbol">(</a><a id="781" href="Agda.Builtin.Bool.html#135" class="Datatype">Bool</a><a id="785" class="Symbol">;</a> <a id="787" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="800" class="Symbol">;</a> <a id="802" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a><a id="806" class="Symbol">;</a> <a id="808" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a><a id="813" class="Symbol">)</a>
<a id="815" class="Keyword">open</a> <a id="820" class="Keyword">import</a> <a id="827" href="Data.Unit.html" class="Module">Data.Unit</a>           <a id="847" class="Keyword">using</a> <a id="853" class="Symbol">(</a><a id="854" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a><a id="855" class="Symbol">)</a>
<a id="857" class="Keyword">open</a> <a id="862" class="Keyword">import</a> <a id="869" href="Data.String.html" class="Module">Data.String</a>         <a id="889" class="Keyword">using</a> <a id="895" class="Symbol">(</a><a id="896" href="Agda.Builtin.String.html#247" class="Postulate">String</a><a id="902" class="Symbol">)</a>
<a id="904" class="Keyword">open</a> <a id="909" class="Keyword">import</a> <a id="916" href="Data.Product.html" class="Module">Data.Product</a>        <a id="936" class="Keyword">using</a> <a id="942" class="Symbol">(</a><a id="943" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a><a id="946" class="Symbol">)</a>
<a id="948" class="Keyword">open</a> <a id="953" class="Keyword">import</a> <a id="960" href="Function.html" class="Module">Function</a>
<a id="969" class="Keyword">open</a> <a id="974" class="Keyword">import</a> <a id="981" href="Reflection.TCMonadSyntax.html" class="Module">Reflection.TCMonadSyntax</a>
<a id="1006" class="Keyword">open</a> <a id="1011" class="Keyword">import</a> <a id="1018" href="Reflection.Argument.html" class="Module">Reflection.Argument</a>
<a id="1038" class="Keyword">open</a> <a id="1043" class="Keyword">import</a> <a id="1050" href="Reflection.Term.html" class="Module">Reflection.Term</a>

<a id="1067" class="Keyword">open</a> <a id="1072" class="Keyword">import</a> <a id="1079" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1111" class="Keyword">renaming</a> <a id="1120" class="Symbol">(</a><a id="1121" href="Tactic.RingSolver.NonReflective.html#2889" class="Function">solve</a> <a id="1127" class="Symbol">to</a> <a id="1130" href="Tactic.RingSolver.NonReflective.html#2889" class="Function">solve-fn</a><a id="1138" class="Symbol">)</a>
<a id="1140" class="Keyword">open</a> <a id="1145" class="Keyword">import</a> <a id="1152" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1197" class="Keyword">open</a> <a id="1202" class="Keyword">import</a> <a id="1209" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1239" class="Symbol">as</a> <a id="1242" class="Module">NatSet</a>
<a id="1249" class="Keyword">open</a> <a id="1254" class="Keyword">import</a> <a id="1261" href="Tactic.RingSolver.Core.ReflectionHelp.html" class="Module">Tactic.RingSolver.Core.ReflectionHelp</a>

<a id="1300" class="Keyword">open</a> <a id="1305" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1223" class="Module">AlmostCommutativeRing</a>

<a id="1328" class="Comment">------------------------------------------------------------------------</a>
<a id="1401" class="Comment">-- Processing</a>
<a id="1415" class="Comment">------------------------------------------------------------------------</a>

<a id="1489" class="Keyword">private</a>
  <a id="1499" class="Keyword">record</a> <a id="RingNames"></a><a id="1506" href="Tactic.RingSolver.html#1506" class="Record">RingNames</a> <a id="1516" class="Symbol">:</a> <a id="1518" class="PrimitiveType">Set</a> <a id="1522" class="Keyword">where</a>
    <a id="1532" class="Keyword">constructor</a> <a id="RingNames.+⇒_*⇒_^⇒_-⇒_"></a><a id="1544" href="Tactic.RingSolver.html#1544" class="InductiveConstructor Operator">+⇒_*⇒_^⇒_-⇒_</a>
    <a id="1561" class="Keyword">field</a>
      <a id="RingNames.+′"></a><a id="1573" href="Tactic.RingSolver.html#1573" class="Field">+′</a> <a id="RingNames.*′"></a><a id="1576" href="Tactic.RingSolver.html#1576" class="Field">*′</a> <a id="RingNames.^′"></a><a id="1579" href="Tactic.RingSolver.html#1579" class="Field">^′</a> <a id="RingNames.-′"></a><a id="1582" href="Tactic.RingSolver.html#1582" class="Field">-′</a> <a id="1585" class="Symbol">:</a> <a id="1587" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="1593" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a>

  <a id="checkIsRing"></a><a id="1601" href="Tactic.RingSolver.html#1601" class="Function">checkIsRing</a> <a id="1613" class="Symbol">:</a> <a id="1615" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="1620" class="Symbol">→</a> <a id="1622" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="1625" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
  <a id="1632" href="Tactic.RingSolver.html#1601" class="Function">checkIsRing</a> <a id="1644" href="Tactic.RingSolver.html#1644" class="Bound">ring</a> <a id="1649" class="Symbol">=</a> <a id="1651" href="Agda.Builtin.Reflection.html#7639" class="Postulate">checkType</a> <a id="1661" href="Tactic.RingSolver.html#1644" class="Bound">ring</a> <a id="1666" class="Symbol">(</a><a id="1667" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="1671" class="Symbol">(</a><a id="1672" class="Keyword">quote</a> <a id="1678" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1223" class="Record">AlmostCommutativeRing</a><a id="1699" class="Symbol">)</a> <a id="1701" class="Symbol">(</a><a id="1702" class="Number">2</a> <a id="1704" href="Reflection.Term.html#2305" class="Function Operator">⋯⟨∷⟩</a> <a id="1709" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="1711" class="Symbol">))</a>

  <a id="getVariableIDs"></a><a id="1717" href="Tactic.RingSolver.html#1717" class="Function">getVariableIDs</a> <a id="1732" class="Symbol">:</a> <a id="1734" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="1739" class="Symbol">→</a> <a id="1741" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="1747" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
  <a id="1756" href="Tactic.RingSolver.html#1717" class="Function">getVariableIDs</a> <a id="1771" class="Symbol">=</a> <a id="1773" href="Tactic.RingSolver.html#1793" class="Function">go</a> <a id="1776" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
    <a id="1783" class="Keyword">where</a>
    <a id="1793" href="Tactic.RingSolver.html#1793" class="Function">go</a> <a id="1796" class="Symbol">:</a> <a id="1798" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="1805" class="Symbol">→</a> <a id="1807" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="1812" class="Symbol">→</a> <a id="1814" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="1820" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
    <a id="1831" href="Tactic.RingSolver.html#1793" class="Function">go</a> <a id="1834" href="Tactic.RingSolver.html#1834" class="Bound">t</a> <a id="1836" class="Symbol">(</a><a id="1837" href="Agda.Builtin.Reflection.html#4822" class="InductiveConstructor">con</a> <a id="1841" class="Symbol">(</a><a id="1842" class="Keyword">quote</a> <a id="1848" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">List._∷_</a><a id="1856" class="Symbol">)</a> <a id="1858" class="Symbol">(_</a> <a id="1861" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1863" class="Symbol">_</a> <a id="1865" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1867" href="Agda.Builtin.Reflection.html#4766" class="InductiveConstructor">var</a> <a id="1871" href="Tactic.RingSolver.html#1871" class="Bound">i</a> <a id="1873" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="1876" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="1880" href="Tactic.RingSolver.html#1880" class="Bound">xs</a> <a id="1883" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="1887" class="Symbol">_))</a> <a id="1891" class="Symbol">=</a> <a id="1893" href="Tactic.RingSolver.html#1793" class="Function">go</a> <a id="1896" class="Symbol">(</a><a id="1897" href="Tactic.RingSolver.Core.NatSet.html#2233" class="Function">insert</a> <a id="1904" href="Tactic.RingSolver.html#1871" class="Bound">i</a> <a id="1906" href="Tactic.RingSolver.html#1834" class="Bound">t</a><a id="1907" class="Symbol">)</a> <a id="1909" href="Tactic.RingSolver.html#1880" class="Bound">xs</a>
    <a id="1916" href="Tactic.RingSolver.html#1793" class="Function">go</a> <a id="1919" href="Tactic.RingSolver.html#1919" class="Bound">t</a> <a id="1921" class="Symbol">(</a><a id="1922" href="Agda.Builtin.Reflection.html#4822" class="InductiveConstructor">con</a> <a id="1926" class="Symbol">(</a><a id="1927" class="Keyword">quote</a> <a id="1933" href="Agda.Builtin.List.html#158" class="InductiveConstructor">List.List.[]</a><a id="1945" class="Symbol">)</a> <a id="1947" class="Symbol">_)</a>                           <a id="1976" class="Symbol">=</a> <a id="1978" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="1983" href="Tactic.RingSolver.html#1919" class="Bound">t</a>
    <a id="1989" href="Tactic.RingSolver.html#1793" class="CatchallClause Function">go</a><a id="1991" class="CatchallClause"> </a><a id="1992" class="CatchallClause Symbol">_</a><a id="1993" class="CatchallClause"> </a><a id="1994" class="CatchallClause Symbol">_</a>                                                      <a id="2049" class="Symbol">=</a> <a id="2051" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a>

  <a id="2062" class="Keyword">module</a> <a id="OverRing"></a><a id="2069" href="Tactic.RingSolver.html#2069" class="Module">OverRing</a> <a id="2078" class="Symbol">(</a><a id="2079" href="Tactic.RingSolver.html#2079" class="Bound">ring</a> <a id="2084" class="Symbol">:</a> <a id="2086" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a><a id="2090" class="Symbol">)</a> <a id="2092" class="Keyword">where</a>

    <a id="2103" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
    <a id="2173" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
    <a id="2242" class="Comment">-- the required ring arguments</a>
    <a id="2277" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
    <a id="OverRing._$ʳ_"></a><a id="2327" href="Tactic.RingSolver.html#2327" class="Function Operator">_$ʳ_</a> <a id="2332" class="Symbol">:</a> <a id="2334" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="2339" class="Symbol">→</a> <a id="2341" href="Reflection.Argument.html#1325" class="Function">Args</a> <a id="2346" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="2351" class="Symbol">→</a> <a id="2353" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
    <a id="2362" href="Tactic.RingSolver.html#2362" class="Bound">nm</a> <a id="2365" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="2368" href="Tactic.RingSolver.html#2368" class="Bound">args</a> <a id="2373" class="Symbol">=</a> <a id="2375" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="2379" href="Tactic.RingSolver.html#2362" class="Bound">nm</a> <a id="2382" class="Symbol">(</a><a id="2383" class="Number">2</a> <a id="2385" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="2390" href="Tactic.RingSolver.html#2079" class="Bound">ring</a> <a id="2395" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="2399" href="Tactic.RingSolver.html#2368" class="Bound">args</a><a id="2403" class="Symbol">)</a>

    <a id="OverRing.checkIsListOfVariables"></a><a id="2410" href="Tactic.RingSolver.html#2410" class="Function">checkIsListOfVariables</a> <a id="2433" class="Symbol">:</a> <a id="2435" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="2440" class="Symbol">→</a> <a id="2442" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="2445" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
    <a id="2454" href="Tactic.RingSolver.html#2410" class="Function">checkIsListOfVariables</a> <a id="2477" href="Tactic.RingSolver.html#2477" class="Bound">xs</a> <a id="2480" class="Symbol">=</a>
      <a id="2488" href="Agda.Builtin.Reflection.html#7639" class="Postulate">checkType</a> <a id="2498" href="Tactic.RingSolver.html#2477" class="Bound">xs</a> <a id="2501" class="Symbol">(</a><a id="2502" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="2506" class="Symbol">(</a><a id="2507" class="Keyword">quote</a> <a id="2513" href="Agda.Builtin.List.html#121" class="Datatype">List</a><a id="2517" class="Symbol">)</a> <a id="2519" class="Symbol">(</a><a id="2520" class="Number">1</a> <a id="2522" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="2527" class="Symbol">(</a><a id="2528" class="Keyword">quote</a> <a id="2534" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1361" class="Field">Carrier</a> <a id="2542" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="2545" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2547" class="Symbol">)</a> <a id="2549" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="2553" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2555" class="Symbol">))</a> <a id="2558" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">&gt;&gt;=</a> <a id="2562" href="Agda.Builtin.Reflection.html#7682" class="Postulate">normalise</a>

    <a id="OverRing.getFieldName"></a><a id="2577" href="Tactic.RingSolver.html#2577" class="Function">getFieldName</a> <a id="2590" class="Symbol">:</a> <a id="2592" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="2597" class="Symbol">→</a> <a id="2599" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="2602" class="Symbol">(</a><a id="2603" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="2609" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a><a id="2613" class="Symbol">)</a>
    <a id="2619" href="Tactic.RingSolver.html#2577" class="Function">getFieldName</a> <a id="2632" href="Tactic.RingSolver.html#2632" class="Bound">nm</a> <a id="2635" class="Symbol">=</a> <a id="2637" href="Agda.Builtin.Reflection.html#7682" class="Postulate">normalise</a> <a id="2647" class="Symbol">(</a><a id="2648" href="Tactic.RingSolver.html#2632" class="Bound">nm</a> <a id="2651" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="2654" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2656" class="Symbol">)</a> <a id="2658" href="Reflection.TCMonadSyntax.html#1142" class="Function Operator">&lt;&amp;&gt;</a> <a id="2662" class="Symbol">λ</a> <a id="2664" class="Keyword">where</a>
      <a id="2676" class="Symbol">(</a><a id="2677" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="2681" href="Tactic.RingSolver.html#2681" class="Bound">f</a> <a id="2683" href="Tactic.RingSolver.html#2683" class="Bound">args</a><a id="2687" class="Symbol">)</a> <a id="2689" class="Symbol">→</a> <a id="2691" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="2696" href="Tactic.RingSolver.html#2681" class="Bound">f</a>
      <a id="2704" class="CatchallClause Symbol">_</a>            <a id="2717" class="Symbol">→</a> <a id="2719" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a>

    <a id="OverRing.getRingOperatorNames"></a><a id="2732" href="Tactic.RingSolver.html#2732" class="Function">getRingOperatorNames</a> <a id="2753" class="Symbol">:</a> <a id="2755" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="2758" href="Tactic.RingSolver.html#1506" class="Record">RingNames</a>
    <a id="2772" href="Tactic.RingSolver.html#2732" class="Function">getRingOperatorNames</a> <a id="2793" class="Symbol">=</a> <a id="2795" class="Symbol">⦇</a>
      <a id="2803" href="Tactic.RingSolver.html#1544" class="InductiveConstructor Operator">+⇒</a> <a id="2806" href="Tactic.RingSolver.html#2577" class="Function">getFieldName</a> <a id="2819" class="Symbol">(</a><a id="2820" class="Keyword">quote</a> <a id="2826" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1441" class="Field Operator">_+_</a><a id="2829" class="Symbol">)</a>
      <a id="2837" href="Tactic.RingSolver.html#1544" class="InductiveConstructor Operator">*⇒</a> <a id="2840" href="Tactic.RingSolver.html#2577" class="Function">getFieldName</a> <a id="2853" class="Symbol">(</a><a id="2854" class="Keyword">quote</a> <a id="2860" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1483" class="Field Operator">_*_</a><a id="2863" class="Symbol">)</a>
      <a id="2871" href="Tactic.RingSolver.html#1544" class="InductiveConstructor Operator">^⇒</a> <a id="2874" href="Tactic.RingSolver.html#2577" class="Function">getFieldName</a> <a id="2887" class="Symbol">(</a><a id="2888" class="Keyword">quote</a> <a id="2894" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2383" class="Function Operator">_^_</a><a id="2897" class="Symbol">)</a>
      <a id="2905" href="Tactic.RingSolver.html#1544" class="InductiveConstructor Operator">-⇒</a> <a id="2908" href="Tactic.RingSolver.html#2577" class="Function">getFieldName</a> <a id="2921" class="Symbol">(</a><a id="2922" class="Keyword">quote</a> <a id="2928" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1525" class="Field Operator">-_</a><a id="2930" class="Symbol">)</a>
      <a id="2938" class="Symbol">⦈</a>

    <a id="2945" class="Keyword">module</a> <a id="2952" href="Tactic.RingSolver.html#2952" class="Module">_</a> <a id="2954" class="Symbol">(</a><a id="2955" href="Tactic.RingSolver.html#2955" class="Bound">nms</a> <a id="2959" class="Symbol">:</a> <a id="2961" href="Tactic.RingSolver.html#1506" class="Record">RingNames</a><a id="2970" class="Symbol">)</a> <a id="2972" class="Symbol">(</a><a id="2973" href="Tactic.RingSolver.html#2973" class="Bound">numVars</a> <a id="2981" class="Symbol">:</a> <a id="2983" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="2984" class="Symbol">)</a> <a id="2986" class="Keyword">where</a>
      <a id="2998" class="Keyword">open</a> <a id="3003" href="Tactic.RingSolver.html#1506" class="Module">RingNames</a> <a id="3013" href="Tactic.RingSolver.html#2955" class="Bound">nms</a>

      <a id="3024" class="Comment">-- This function applies the hidden arguments that the constructors</a>
      <a id="3098" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
      <a id="3175" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
      <a id="3248" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
      <a id="3321" class="Comment">-- make things easier we supply the third because we know it.</a>
      <a id="3389" href="Tactic.RingSolver.html#3389" class="Function Operator">_$ᵉ_</a> <a id="3394" class="Symbol">:</a> <a id="3396" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="3401" class="Symbol">→</a> <a id="3403" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="3408" class="Symbol">(</a><a id="3409" href="Agda.Builtin.Reflection.html#3199" class="Datatype">Arg</a> <a id="3413" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a><a id="3417" class="Symbol">)</a> <a id="3419" class="Symbol">→</a> <a id="3421" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
      <a id="3432" href="Tactic.RingSolver.html#3432" class="Bound">e</a> <a id="3434" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="3437" href="Tactic.RingSolver.html#3437" class="Bound">xs</a> <a id="3440" class="Symbol">=</a> <a id="3442" href="Agda.Builtin.Reflection.html#4822" class="InductiveConstructor">con</a> <a id="3446" href="Tactic.RingSolver.html#3432" class="Bound">e</a> <a id="3448" class="Symbol">(</a><a id="3449" class="Number">1</a> <a id="3451" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="3456" class="Keyword">quote</a> <a id="3462" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1361" class="Field">Carrier</a> <a id="3470" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="3473" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="3476" href="Reflection.Argument.html#1449" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="3480" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="3487" href="Tactic.RingSolver.html#2973" class="Bound">numVars</a> <a id="3495" href="Reflection.Argument.html#1449" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="3499" href="Tactic.RingSolver.html#3437" class="Bound">xs</a><a id="3501" class="Symbol">)</a>

      <a id="3510" class="Comment">-- A constant expression.</a>
      <a id="3542" href="Tactic.RingSolver.html#3542" class="Function">Κ′</a> <a id="3545" class="Symbol">:</a> <a id="3547" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="3552" class="Symbol">→</a> <a id="3554" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
      <a id="3565" href="Tactic.RingSolver.html#3542" class="Function">Κ′</a> <a id="3568" href="Tactic.RingSolver.html#3568" class="Bound">x</a> <a id="3570" class="Symbol">=</a> <a id="3572" class="Keyword">quote</a> <a id="3578" href="Tactic.RingSolver.Core.Expression.html#538" class="InductiveConstructor">Κ</a> <a id="3580" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="3583" class="Symbol">(</a><a id="3584" href="Tactic.RingSolver.html#3568" class="Bound">x</a> <a id="3586" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3590" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3592" class="Symbol">)</a>

      <a id="3601" href="Tactic.RingSolver.html#3601" class="Function Operator">_⇓≟_</a> <a id="3606" class="Symbol">:</a> <a id="3608" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="3614" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="3619" class="Symbol">→</a> <a id="3621" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="3626" class="Symbol">→</a> <a id="3628" href="Agda.Builtin.Bool.html#135" class="Datatype">Bool</a>
      <a id="3639" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a> <a id="3647" href="Tactic.RingSolver.html#3601" class="Function Operator">⇓≟</a> <a id="3650" class="Symbol">_</a> <a id="3652" class="Symbol">=</a> <a id="3654" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a>
      <a id="3666" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="3671" href="Tactic.RingSolver.html#3671" class="Bound">x</a>  <a id="3674" href="Tactic.RingSolver.html#3601" class="Function Operator">⇓≟</a> <a id="3677" href="Tactic.RingSolver.html#3677" class="Bound">y</a> <a id="3679" class="Symbol">=</a> <a id="3681" href="Agda.Builtin.Reflection.html#486" class="Primitive">primQNameEquality</a> <a id="3699" href="Tactic.RingSolver.html#3671" class="Bound">x</a> <a id="3701" href="Tactic.RingSolver.html#3677" class="Bound">y</a>
      <a id="3709" class="Symbol">{-#</a> <a id="3713" class="Keyword">INLINE</a> <a id="3720" href="Tactic.RingSolver.html#3601" class="Function Operator">_⇓≟_</a> <a id="3725" class="Symbol">#-}</a>

      <a id="3736" class="Keyword">module</a> <a id="ToExpr"></a><a id="3743" href="Tactic.RingSolver.html#3743" class="Module">ToExpr</a> <a id="3750" class="Symbol">(</a><a id="3751" href="Tactic.RingSolver.html#3751" class="Bound">Ι′</a> <a id="3754" class="Symbol">:</a> <a id="3756" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="3758" class="Symbol">→</a> <a id="3760" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="3766" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a><a id="3770" class="Symbol">)</a> <a id="3772" class="Keyword">where</a>
        <a id="3786" class="Keyword">mutual</a>
          <a id="3803" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
          <a id="3876" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
          <a id="3950" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
          <a id="4023" class="Comment">-- by just taking the last two explicit arguments.</a>
          <a id="4084" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨_⟩₂</a> <a id="4090" class="Symbol">:</a> <a id="4092" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="4097" class="Symbol">→</a> <a id="4099" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="4104" class="Symbol">(</a><a id="4105" href="Agda.Builtin.Reflection.html#3199" class="Datatype">Arg</a> <a id="4109" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a><a id="4113" class="Symbol">)</a> <a id="4115" class="Symbol">→</a> <a id="4117" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
          <a id="4132" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨</a> <a id="4135" href="Tactic.RingSolver.html#4135" class="Bound">nm</a> <a id="4138" href="Tactic.RingSolver.html#4084" class="Function Operator">⟩₂</a> <a id="4141" class="Symbol">(</a><a id="4142" href="Tactic.RingSolver.html#4142" class="Bound">x</a> <a id="4144" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4148" href="Tactic.RingSolver.html#4148" class="Bound">y</a> <a id="4150" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4154" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4156" class="Symbol">)</a> <a id="4158" class="Symbol">=</a> <a id="4160" href="Tactic.RingSolver.html#4135" class="Bound">nm</a> <a id="4163" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="4166" class="Symbol">(</a><a id="4167" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="4169" href="Tactic.RingSolver.html#4142" class="Bound">x</a> <a id="4171" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4175" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="4177" href="Tactic.RingSolver.html#4148" class="Bound">y</a> <a id="4179" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4183" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4185" class="Symbol">)</a>
          <a id="4197" href="Tactic.RingSolver.html#4084" class="CatchallClause Function Operator">E⟨</a><a id="4199" class="CatchallClause"> </a><a id="4200" href="Tactic.RingSolver.html#4200" class="CatchallClause Bound">nm</a><a id="4202" class="CatchallClause"> </a><a id="4203" href="Tactic.RingSolver.html#4084" class="CatchallClause Function Operator">⟩₂</a><a id="4205" class="CatchallClause"> </a><a id="4206" class="CatchallClause Symbol">(</a><a id="4207" href="Tactic.RingSolver.html#4207" class="CatchallClause Bound">x</a><a id="4208" class="CatchallClause"> </a><a id="4209" href="Agda.Builtin.List.html#173" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4210" class="CatchallClause"> </a><a id="4211" href="Tactic.RingSolver.html#4211" class="CatchallClause Bound">xs</a><a id="4213" class="CatchallClause Symbol">)</a>         <a id="4223" class="Symbol">=</a> <a id="4225" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨</a> <a id="4228" href="Tactic.RingSolver.html#4200" class="Bound">nm</a> <a id="4231" href="Tactic.RingSolver.html#4084" class="Function Operator">⟩₂</a> <a id="4234" href="Tactic.RingSolver.html#4211" class="Bound">xs</a>
          <a id="4247" href="Tactic.RingSolver.html#4084" class="CatchallClause Function Operator">E⟨</a><a id="4249" class="CatchallClause"> </a><a id="4250" href="Tactic.RingSolver.html#4250" class="CatchallClause Bound">nm</a><a id="4252" class="CatchallClause"> </a><a id="4253" href="Tactic.RingSolver.html#4084" class="CatchallClause Function Operator">⟩₂</a><a id="4255" class="CatchallClause"> </a><a id="4256" class="CatchallClause Symbol">_</a>                <a id="4273" class="Symbol">=</a> <a id="4275" href="Agda.Builtin.Reflection.html#5222" class="InductiveConstructor">unknown</a>

          <a id="4294" href="Tactic.RingSolver.html#4294" class="Function Operator">E⟨_⟩₁</a> <a id="4300" class="Symbol">:</a> <a id="4302" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="4307" class="Symbol">→</a> <a id="4309" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="4314" class="Symbol">(</a><a id="4315" href="Agda.Builtin.Reflection.html#3199" class="Datatype">Arg</a> <a id="4319" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a><a id="4323" class="Symbol">)</a> <a id="4325" class="Symbol">→</a> <a id="4327" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
          <a id="4342" href="Tactic.RingSolver.html#4294" class="Function Operator">E⟨</a> <a id="4345" href="Tactic.RingSolver.html#4345" class="Bound">nm</a> <a id="4348" href="Tactic.RingSolver.html#4294" class="Function Operator">⟩₁</a> <a id="4351" class="Symbol">(</a><a id="4352" href="Tactic.RingSolver.html#4352" class="Bound">x</a> <a id="4354" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4358" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4360" class="Symbol">)</a> <a id="4362" class="Symbol">=</a> <a id="4364" href="Tactic.RingSolver.html#4345" class="Bound">nm</a> <a id="4367" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="4370" class="Symbol">(</a><a id="4371" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="4373" href="Tactic.RingSolver.html#4352" class="Bound">x</a> <a id="4375" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4379" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4381" class="Symbol">)</a>
          <a id="4393" href="Tactic.RingSolver.html#4294" class="CatchallClause Function Operator">E⟨</a><a id="4395" class="CatchallClause"> </a><a id="4396" href="Tactic.RingSolver.html#4396" class="CatchallClause Bound">nm</a><a id="4398" class="CatchallClause"> </a><a id="4399" href="Tactic.RingSolver.html#4294" class="CatchallClause Function Operator">⟩₁</a><a id="4401" class="CatchallClause"> </a><a id="4402" class="CatchallClause Symbol">(</a><a id="4403" href="Tactic.RingSolver.html#4403" class="CatchallClause Bound">x</a><a id="4404" class="CatchallClause"> </a><a id="4405" href="Agda.Builtin.List.html#173" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4406" class="CatchallClause"> </a><a id="4407" href="Tactic.RingSolver.html#4407" class="CatchallClause Bound">xs</a><a id="4409" class="CatchallClause Symbol">)</a>   <a id="4413" class="Symbol">=</a> <a id="4415" href="Tactic.RingSolver.html#4294" class="Function Operator">E⟨</a> <a id="4418" href="Tactic.RingSolver.html#4396" class="Bound">nm</a> <a id="4421" href="Tactic.RingSolver.html#4294" class="Function Operator">⟩₁</a> <a id="4424" href="Tactic.RingSolver.html#4407" class="Bound">xs</a>
          <a id="4437" href="Tactic.RingSolver.html#4294" class="CatchallClause Function Operator">E⟨</a><a id="4439" class="CatchallClause"> </a><a id="4440" class="CatchallClause Symbol">_</a><a id="4441" class="CatchallClause">  </a><a id="4443" href="Tactic.RingSolver.html#4294" class="CatchallClause Function Operator">⟩₁</a><a id="4445" class="CatchallClause"> </a><a id="4446" class="CatchallClause Symbol">_</a>          <a id="4457" class="Symbol">=</a> <a id="4459" href="Agda.Builtin.Reflection.html#5222" class="InductiveConstructor">unknown</a>

          <a id="4478" href="Tactic.RingSolver.html#4478" class="Function">E⟨^⟩</a> <a id="4483" class="Symbol">:</a> <a id="4485" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="4490" class="Symbol">(</a><a id="4491" href="Agda.Builtin.Reflection.html#3199" class="Datatype">Arg</a> <a id="4495" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a><a id="4499" class="Symbol">)</a> <a id="4501" class="Symbol">→</a> <a id="4503" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
          <a id="4518" href="Tactic.RingSolver.html#4478" class="Function">E⟨^⟩</a> <a id="4523" class="Symbol">(</a><a id="4524" href="Tactic.RingSolver.html#4524" class="Bound">x</a> <a id="4526" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4530" href="Tactic.RingSolver.html#4530" class="Bound">y</a> <a id="4532" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4536" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4538" class="Symbol">)</a> <a id="4540" class="Symbol">=</a> <a id="4542" class="Keyword">quote</a> <a id="4548" href="Tactic.RingSolver.Core.Expression.html#748" class="InductiveConstructor Operator">_⊛_</a> <a id="4552" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="4555" class="Symbol">(</a><a id="4556" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="4558" href="Tactic.RingSolver.html#4524" class="Bound">x</a> <a id="4560" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4564" href="Tactic.RingSolver.html#4530" class="Bound">y</a> <a id="4566" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4570" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4572" class="Symbol">)</a>
          <a id="4584" href="Tactic.RingSolver.html#4478" class="CatchallClause Function">E⟨^⟩</a><a id="4588" class="CatchallClause"> </a><a id="4589" class="CatchallClause Symbol">(</a><a id="4590" href="Tactic.RingSolver.html#4590" class="CatchallClause Bound">x</a><a id="4591" class="CatchallClause"> </a><a id="4592" href="Agda.Builtin.List.html#173" class="CatchallClause InductiveConstructor Operator">∷</a><a id="4593" class="CatchallClause"> </a><a id="4594" href="Tactic.RingSolver.html#4594" class="CatchallClause Bound">xs</a><a id="4596" class="CatchallClause Symbol">)</a>         <a id="4606" class="Symbol">=</a> <a id="4608" href="Tactic.RingSolver.html#4478" class="Function">E⟨^⟩</a> <a id="4613" href="Tactic.RingSolver.html#4594" class="Bound">xs</a>
          <a id="4626" href="Tactic.RingSolver.html#4478" class="CatchallClause Function">E⟨^⟩</a><a id="4630" class="CatchallClause"> </a><a id="4631" class="CatchallClause Symbol">_</a>                <a id="4648" class="Symbol">=</a> <a id="4650" href="Agda.Builtin.Reflection.html#5222" class="InductiveConstructor">unknown</a>

          <a id="4669" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
          <a id="4743" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
          <a id="4814" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
          <a id="4888" class="Comment">-- might look for its constructors: however, we want to deal with</a>
          <a id="4964" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
          <a id="5039" class="Comment">-- Term type contained type information we might be able to</a>
          <a id="5109" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
          <a id="5158" class="Comment">--</a>
          <a id="5171" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
          <a id="5248" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
          <a id="5324" class="Comment">-- will just assume that it has a constant expression.</a>
          <a id="5389" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="5391" class="Symbol">:</a> <a id="5393" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="5398" class="Symbol">→</a> <a id="5400" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
          <a id="5415" class="Comment">-- Recognise the ring&#39;s fields</a>
          <a id="5456" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="5458" class="Symbol">(</a><a id="5459" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="5463" class="Symbol">(</a><a id="5464" class="Keyword">quote</a> <a id="5470" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1441" class="Field Operator">_+_</a><a id="5473" class="Symbol">)</a> <a id="5475" href="Tactic.RingSolver.html#5475" class="Bound">xs</a><a id="5477" class="Symbol">)</a> <a id="5479" class="Symbol">=</a> <a id="5481" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨</a> <a id="5484" class="Keyword">quote</a> <a id="5490" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="5494" href="Tactic.RingSolver.html#4084" class="Function Operator">⟩₂</a> <a id="5497" href="Tactic.RingSolver.html#5475" class="Bound">xs</a>
          <a id="5510" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="5512" class="Symbol">(</a><a id="5513" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="5517" class="Symbol">(</a><a id="5518" class="Keyword">quote</a> <a id="5524" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1483" class="Field Operator">_*_</a><a id="5527" class="Symbol">)</a> <a id="5529" href="Tactic.RingSolver.html#5529" class="Bound">xs</a><a id="5531" class="Symbol">)</a> <a id="5533" class="Symbol">=</a> <a id="5535" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨</a> <a id="5538" class="Keyword">quote</a> <a id="5544" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a> <a id="5548" href="Tactic.RingSolver.html#4084" class="Function Operator">⟩₂</a> <a id="5551" href="Tactic.RingSolver.html#5529" class="Bound">xs</a>
          <a id="5564" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="5566" class="Symbol">(</a><a id="5567" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="5571" class="Symbol">(</a><a id="5572" class="Keyword">quote</a> <a id="5578" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2383" class="Function Operator">_^_</a><a id="5581" class="Symbol">)</a> <a id="5583" href="Tactic.RingSolver.html#5583" class="Bound">xs</a><a id="5585" class="Symbol">)</a> <a id="5587" class="Symbol">=</a> <a id="5589" href="Tactic.RingSolver.html#4478" class="Function">E⟨^⟩</a> <a id="5594" href="Tactic.RingSolver.html#5583" class="Bound">xs</a>
          <a id="5607" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="5609" class="Symbol">(</a><a id="5610" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="5614" class="Symbol">(</a><a id="5615" class="Keyword">quote</a> <a id="5621" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1525" class="Field Operator">-_</a><a id="5623" class="Symbol">)</a>  <a id="5626" href="Tactic.RingSolver.html#5626" class="Bound">xs</a><a id="5628" class="Symbol">)</a> <a id="5630" class="Symbol">=</a> <a id="5632" href="Tactic.RingSolver.html#4294" class="Function Operator">E⟨</a> <a id="5635" class="Keyword">quote</a> <a id="5641" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a> <a id="5644" href="Tactic.RingSolver.html#4294" class="Function Operator">⟩₁</a> <a id="5647" href="Tactic.RingSolver.html#5626" class="Bound">xs</a>
          <a id="5660" class="Comment">-- Recognise the underlying implementation of the ring&#39;s fields</a>
          <a id="5734" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="5736" class="Symbol">(</a><a id="5737" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="5741" href="Tactic.RingSolver.html#5741" class="Bound">nm</a>          <a id="5753" href="Tactic.RingSolver.html#5753" class="Bound">xs</a><a id="5755" class="Symbol">)</a> <a id="5757" class="Symbol">=</a> <a id="5759" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5762" href="Tactic.RingSolver.html#1573" class="Function">+′</a> <a id="5765" href="Tactic.RingSolver.html#3601" class="Function Operator">⇓≟</a> <a id="5768" href="Tactic.RingSolver.html#5741" class="Bound">nm</a> <a id="5771" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5776" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨</a> <a id="5779" class="Keyword">quote</a> <a id="5785" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="5789" href="Tactic.RingSolver.html#4084" class="Function Operator">⟩₂</a> <a id="5792" href="Tactic.RingSolver.html#5753" class="Bound">xs</a> <a id="5795" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="5835" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5838" href="Tactic.RingSolver.html#1576" class="Function">*′</a> <a id="5841" href="Tactic.RingSolver.html#3601" class="Function Operator">⇓≟</a> <a id="5844" href="Tactic.RingSolver.html#5741" class="Bound">nm</a> <a id="5847" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5852" href="Tactic.RingSolver.html#4084" class="Function Operator">E⟨</a> <a id="5855" class="Keyword">quote</a> <a id="5861" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a> <a id="5865" href="Tactic.RingSolver.html#4084" class="Function Operator">⟩₂</a> <a id="5868" href="Tactic.RingSolver.html#5753" class="Bound">xs</a> <a id="5871" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="5911" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5914" href="Tactic.RingSolver.html#1579" class="Function">^′</a> <a id="5917" href="Tactic.RingSolver.html#3601" class="Function Operator">⇓≟</a> <a id="5920" href="Tactic.RingSolver.html#5741" class="Bound">nm</a> <a id="5923" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5928" href="Tactic.RingSolver.html#4478" class="Function">E⟨^⟩</a> <a id="5933" href="Tactic.RingSolver.html#5753" class="Bound">xs</a> <a id="5936" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="5976" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="5979" href="Tactic.RingSolver.html#1582" class="Function">-′</a> <a id="5982" href="Tactic.RingSolver.html#3601" class="Function Operator">⇓≟</a> <a id="5985" href="Tactic.RingSolver.html#5741" class="Bound">nm</a> <a id="5988" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="5993" href="Tactic.RingSolver.html#4294" class="Function Operator">E⟨</a> <a id="5996" class="Keyword">quote</a> <a id="6002" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a> <a id="6005" href="Tactic.RingSolver.html#4294" class="Function Operator">⟩₁</a> <a id="6008" href="Tactic.RingSolver.html#5753" class="Bound">xs</a> <a id="6011" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                                   <a id="6051" href="Tactic.RingSolver.html#3542" class="Function">Κ′</a> <a id="6054" class="Symbol">(</a><a id="6055" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="6059" href="Tactic.RingSolver.html#5741" class="Bound">nm</a> <a id="6062" href="Tactic.RingSolver.html#5753" class="Bound">xs</a><a id="6064" class="Symbol">)</a>
          <a id="6076" class="Comment">-- Variables</a>
          <a id="6099" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="6101" href="Tactic.RingSolver.html#6101" class="Bound">v</a><a id="6102" class="Symbol">@(</a><a id="6104" href="Agda.Builtin.Reflection.html#4766" class="InductiveConstructor">var</a> <a id="6108" href="Tactic.RingSolver.html#6108" class="Bound">x</a> <a id="6110" class="Symbol">_)</a>          <a id="6122" class="Symbol">=</a> <a id="6124" href="Data.Maybe.Base.html#1651" class="Function">fromMaybe</a> <a id="6134" class="Symbol">(</a><a id="6135" href="Tactic.RingSolver.html#3542" class="Function">Κ′</a> <a id="6138" href="Tactic.RingSolver.html#6101" class="Bound">v</a><a id="6139" class="Symbol">)</a> <a id="6141" class="Symbol">(</a><a id="6142" href="Tactic.RingSolver.html#3751" class="Bound">Ι′</a> <a id="6145" href="Tactic.RingSolver.html#6108" class="Bound">x</a><a id="6146" class="Symbol">)</a>
          <a id="6158" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
          <a id="6216" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="6218" class="Symbol">(</a><a id="6219" href="Agda.Builtin.Reflection.html#4822" class="InductiveConstructor">con</a> <a id="6223" class="Symbol">(</a><a id="6224" class="Keyword">quote</a> <a id="6230" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">ℕ.suc</a><a id="6235" class="Symbol">)</a> <a id="6237" class="Symbol">(</a><a id="6238" href="Tactic.RingSolver.html#6238" class="Bound">x</a> <a id="6240" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6244" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6246" class="Symbol">))</a> <a id="6249" class="Symbol">=</a> <a id="6251" class="Keyword">quote</a> <a id="6257" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="6261" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="6264" class="Symbol">(</a><a id="6265" href="Tactic.RingSolver.html#3542" class="Function">Κ′</a> <a id="6268" class="Symbol">(</a><a id="6269" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="6276" class="Number">1</a><a id="6277" class="Symbol">)</a> <a id="6279" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6283" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="6285" href="Tactic.RingSolver.html#6238" class="Bound">x</a> <a id="6287" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6291" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6293" class="Symbol">)</a>
          <a id="6305" href="Tactic.RingSolver.html#5389" class="CatchallClause Function">E</a><a id="6306" class="CatchallClause"> </a><a id="6307" href="Tactic.RingSolver.html#6307" class="CatchallClause Bound">t</a>                    <a id="6328" class="Symbol">=</a> <a id="6330" href="Tactic.RingSolver.html#3542" class="Function">Κ′</a> <a id="6333" href="Tactic.RingSolver.html#6307" class="Bound">t</a>

      <a id="6342" href="Tactic.RingSolver.html#6342" class="Function">callSolver</a> <a id="6353" class="Symbol">:</a> <a id="6355" href="Data.Vec.Base.html#959" class="Datatype">Vec</a> <a id="6359" href="Agda.Builtin.String.html#247" class="Postulate">String</a> <a id="6366" href="Tactic.RingSolver.html#2973" class="Bound">numVars</a> <a id="6374" class="Symbol">→</a> <a id="6376" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="6381" class="Symbol">→</a> <a id="6383" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="6388" class="Symbol">→</a> <a id="6390" href="Reflection.Argument.html#1325" class="Function">Args</a> <a id="6395" href="Agda.Builtin.Reflection.html#4735" class="Function">Type</a>
      <a id="6406" href="Tactic.RingSolver.html#6342" class="Function">callSolver</a> <a id="6417" href="Tactic.RingSolver.html#6417" class="Bound">nms</a> <a id="6421" href="Tactic.RingSolver.html#6421" class="Bound">lhs</a> <a id="6425" href="Tactic.RingSolver.html#6425" class="Bound">rhs</a> <a id="6429" class="Symbol">=</a>
          <a id="6441" class="Number">2</a> <a id="6443" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="6448" href="Tactic.RingSolver.html#2079" class="Bound">ring</a> <a id="6453" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6457" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="6464" href="Tactic.RingSolver.html#2973" class="Bound">numVars</a> <a id="6472" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6486" href="Tactic.RingSolver.Core.ReflectionHelp.html#1142" class="Function">vlams</a> <a id="6492" href="Tactic.RingSolver.html#6417" class="Bound">nms</a> <a id="6496" class="Symbol">(</a><a id="6497" class="Keyword">quote</a> <a id="6503" href="Tactic.RingSolver.NonReflective.html#3238" class="Function Operator">_⊜_</a>  <a id="6508" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="6511" class="Symbol">(</a><a id="6512" href="Data.Nat.Reflection.html#525" class="Function">toTerm</a> <a id="6519" href="Tactic.RingSolver.html#2973" class="Bound">numVars</a> <a id="6527" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6531" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="6533" href="Tactic.RingSolver.html#6421" class="Bound">lhs</a> <a id="6537" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6541" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="6543" href="Tactic.RingSolver.html#6425" class="Bound">rhs</a> <a id="6547" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6551" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6553" class="Symbol">))</a> <a id="6556" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6570" href="Tactic.RingSolver.Core.ReflectionHelp.html#1022" class="Function">hlams</a> <a id="6576" href="Tactic.RingSolver.html#6417" class="Bound">nms</a> <a id="6580" class="Symbol">(</a><a id="6581" class="Keyword">quote</a> <a id="6587" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2461" class="Function">refl</a> <a id="6592" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="6595" class="Symbol">(</a><a id="6596" class="Number">1</a> <a id="6598" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="6603" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6605" class="Symbol">))</a> <a id="6608" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
          <a id="6622" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
        <a id="6633" class="Keyword">where</a>
        <a id="6647" href="Tactic.RingSolver.html#6647" class="Function">Ι′</a> <a id="6650" class="Symbol">:</a> <a id="6652" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="6654" class="Symbol">→</a> <a id="6656" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="6662" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
        <a id="6675" href="Tactic.RingSolver.html#6647" class="Function">Ι′</a> <a id="6678" href="Tactic.RingSolver.html#6678" class="Bound">i</a> <a id="6680" class="Symbol">=</a> <a id="6682" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="6685" href="Tactic.RingSolver.html#6678" class="Bound">i</a> <a id="6687" href="Agda.Builtin.Nat.html#719" class="Primitive Operator">&lt;ᵇ</a> <a id="6690" href="Tactic.RingSolver.html#2973" class="Bound">numVars</a> <a id="6698" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="6703" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="6708" class="Symbol">(</a><a id="6709" href="Agda.Builtin.Reflection.html#4766" class="InductiveConstructor">var</a> <a id="6713" href="Tactic.RingSolver.html#6678" class="Bound">i</a> <a id="6715" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6717" class="Symbol">)</a> <a id="6719" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="6724" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a>
        <a id="6740" class="Keyword">open</a> <a id="6745" href="Tactic.RingSolver.html#3743" class="Module">ToExpr</a> <a id="6752" href="Tactic.RingSolver.html#6647" class="Function">Ι′</a>

      <a id="6762" href="Tactic.RingSolver.html#6762" class="Function">constructSoln</a> <a id="6776" class="Symbol">:</a> <a id="6778" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="6785" class="Symbol">→</a> <a id="6787" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="6792" class="Symbol">→</a> <a id="6794" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="6799" class="Symbol">→</a> <a id="6801" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
      <a id="6812" href="Tactic.RingSolver.html#6762" class="Function">constructSoln</a> <a id="6826" href="Tactic.RingSolver.html#6826" class="Bound">t</a> <a id="6828" href="Tactic.RingSolver.html#6828" class="Bound">lhs</a> <a id="6832" href="Tactic.RingSolver.html#6832" class="Bound">rhs</a> <a id="6836" class="Symbol">=</a>
          <a id="6848" class="Keyword">quote</a> <a id="6854" href="Relation.Binary.Structures.html#1620" class="Function">trans</a> <a id="6860" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="6863" class="Symbol">(</a><a id="6864" class="Number">3</a> <a id="6866" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a>
            <a id="6883" class="Keyword">quote</a> <a id="6889" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="6893" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="6896" class="Symbol">(</a><a id="6897" class="Number">2</a> <a id="6899" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a>
              <a id="6918" class="Keyword">quote</a> <a id="6924" href="Tactic.RingSolver.NonReflective.html#2224" class="Function">Ops.correct</a> <a id="6936" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="6939" class="Symbol">(</a><a id="6940" class="Number">1</a> <a id="6942" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="6947" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="6949" href="Tactic.RingSolver.html#6828" class="Bound">lhs</a> <a id="6953" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6957" href="Tactic.RingSolver.html#7226" class="Function">ρ</a> <a id="6959" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6963" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6965" class="Symbol">)</a> <a id="6967" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="6971" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="6973" class="Symbol">)</a>
            <a id="6987" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
            <a id="7003" class="Symbol">(</a><a id="7004" class="Keyword">quote</a> <a id="7010" href="Tactic.RingSolver.NonReflective.html#2224" class="Function">Ops.correct</a> <a id="7022" href="Tactic.RingSolver.html#2327" class="Function Operator">$ʳ</a> <a id="7025" class="Symbol">(</a><a id="7026" class="Number">1</a> <a id="7028" href="Reflection.Term.html#2618" class="Function Operator">⋯⟅∷⟆</a> <a id="7033" href="Tactic.RingSolver.html#5389" class="Function">E</a> <a id="7035" href="Tactic.RingSolver.html#6832" class="Bound">rhs</a> <a id="7039" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7043" href="Tactic.RingSolver.html#7226" class="Function">ρ</a> <a id="7045" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7049" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="7051" class="Symbol">))</a> <a id="7054" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a>
            <a id="7070" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="7072" class="Symbol">)</a>
        <a id="7082" class="Keyword">where</a>
        <a id="7096" href="Tactic.RingSolver.html#7096" class="Function">Ι′</a> <a id="7099" class="Symbol">:</a> <a id="7101" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="7103" class="Symbol">→</a> <a id="7105" href="Data.Maybe.Base.html#838" class="Datatype">Maybe</a> <a id="7111" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
        <a id="7124" href="Tactic.RingSolver.html#7096" class="Function">Ι′</a> <a id="7127" href="Tactic.RingSolver.html#7127" class="Bound">i</a> <a id="7129" class="Symbol">=</a> <a id="7131" href="Data.Maybe.Base.html#2039" class="Function">Maybe.map</a> <a id="7141" class="Symbol">(λ</a> <a id="7144" href="Tactic.RingSolver.html#7144" class="Bound">x</a> <a id="7146" class="Symbol">→</a> <a id="7148" class="Keyword">quote</a> <a id="7154" href="Tactic.RingSolver.Core.Expression.html#589" class="InductiveConstructor">Ι</a> <a id="7156" href="Tactic.RingSolver.html#3389" class="Function Operator">$ᵉ</a> <a id="7159" class="Symbol">(</a><a id="7160" href="Data.Nat.Reflection.html#637" class="Function">toFinTerm</a> <a id="7170" href="Tactic.RingSolver.html#7144" class="Bound">x</a> <a id="7172" href="Reflection.Argument.html#1416" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7176" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="7178" class="Symbol">))</a> <a id="7181" class="Symbol">(</a><a id="7182" href="Tactic.RingSolver.Core.NatSet.html#2881" class="Function">lookup</a> <a id="7189" href="Tactic.RingSolver.html#7127" class="Bound">i</a> <a id="7191" href="Tactic.RingSolver.html#6826" class="Bound">t</a><a id="7192" class="Symbol">)</a>

        <a id="7203" class="Keyword">open</a> <a id="7208" href="Tactic.RingSolver.html#3743" class="Module">ToExpr</a> <a id="7215" href="Tactic.RingSolver.html#7096" class="Function">Ι′</a>
        <a id="7226" href="Tactic.RingSolver.html#7226" class="Function">ρ</a> <a id="7228" class="Symbol">:</a> <a id="7230" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a>
        <a id="7243" href="Tactic.RingSolver.html#7226" class="Function">ρ</a> <a id="7245" class="Symbol">=</a> <a id="7247" href="Tactic.RingSolver.Core.ReflectionHelp.html#2013" class="Function">curriedTerm</a> <a id="7259" href="Tactic.RingSolver.html#6826" class="Bound">t</a>

<a id="7262" class="Comment">------------------------------------------------------------------------</a>
<a id="7335" class="Comment">-- Macros</a>
<a id="7345" class="Comment">------------------------------------------------------------------------</a>

<a id="7419" class="Comment">-- This is the main macro which solves for equations in which the variables</a>
<a id="7495" class="Comment">-- are universally quantified over:</a>
<a id="7531" class="Comment">--</a>
<a id="7534" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="7569" class="Comment">--   lemma = solve-∀ TypeRing</a>
<a id="7599" class="Comment">--</a>
<a id="7602" class="Comment">-- where TypRing is your implementation of AlmostCommutativeRing. (Find some</a>
<a id="7679" class="Comment">-- example implementations in Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>

<a id="solve-∀-macro"></a><a id="7767" href="Tactic.RingSolver.html#7767" class="Function">solve-∀-macro</a> <a id="7781" class="Symbol">:</a> <a id="7783" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="7788" class="Symbol">→</a> <a id="7790" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="7795" class="Symbol">→</a> <a id="7797" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="7800" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a>
<a id="7802" href="Tactic.RingSolver.html#7767" class="Function">solve-∀-macro</a> <a id="7816" href="Tactic.RingSolver.html#7816" class="Bound">ring</a> <a id="7821" href="Tactic.RingSolver.html#7821" class="Bound">hole</a> <a id="7826" class="Symbol">=</a> <a id="7828" class="Keyword">do</a>
  <a id="7833" href="Tactic.RingSolver.html#7833" class="Bound">ring′</a> <a id="7839" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="7841" href="Tactic.RingSolver.html#1601" class="Function">checkIsRing</a> <a id="7853" class="Symbol">(</a><a id="7854" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="7858" href="Tactic.RingSolver.html#7816" class="Bound">ring</a> <a id="7863" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="7865" class="Symbol">)</a>
  <a id="7869" href="Agda.Builtin.Reflection.html#8401" class="Postulate">commitTC</a>
  <a id="7880" class="Keyword">let</a> <a id="7884" class="Keyword">open</a> <a id="7889" href="Tactic.RingSolver.html#2069" class="Module">OverRing</a> <a id="7898" href="Tactic.RingSolver.html#7833" class="Bound">ring′</a>
  <a id="7906" href="Tactic.RingSolver.html#7906" class="Bound">operatorNames</a> <a id="7920" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="7922" href="Tactic.RingSolver.html#2732" class="Function">getRingOperatorNames</a>
  <a id="7945" href="Tactic.RingSolver.html#7945" class="Bound">hole′</a> <a id="7951" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="7953" href="Agda.Builtin.Reflection.html#7603" class="Postulate">inferType</a> <a id="7963" href="Tactic.RingSolver.html#7821" class="Bound">hole</a> <a id="7968" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">&gt;&gt;=</a> <a id="7972" href="Agda.Builtin.Reflection.html#7718" class="Postulate">reduce</a>
  <a id="7981" class="Keyword">let</a> <a id="7985" href="Tactic.RingSolver.html#7985" class="Bound">variables</a> <a id="7995" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="7997" href="Tactic.RingSolver.html#7997" class="Bound">k</a> <a id="7999" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="8001" href="Tactic.RingSolver.html#8001" class="Bound">equation</a> <a id="8010" class="Symbol">=</a> <a id="8012" href="Tactic.RingSolver.Core.ReflectionHelp.html#1794" class="Function">underPi</a> <a id="8020" href="Tactic.RingSolver.html#7945" class="Bound">hole′</a>
  <a id="8028" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="8033" class="Symbol">(</a><a id="8034" href="Tactic.RingSolver.html#8034" class="Bound">lhs</a> <a id="8038" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="8040" href="Tactic.RingSolver.html#8040" class="Bound">rhs</a> <a id="8044" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="8046" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="8048" class="Symbol">)</a> <a id="8050" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="8052" href="Reflection.TCMonadSyntax.html#511" class="Function">pure</a> <a id="8057" class="Symbol">(</a><a id="8058" href="Tactic.RingSolver.Core.ReflectionHelp.html#1412" class="Function">getArgs</a> <a id="8066" class="Number">2</a> <a id="8068" href="Tactic.RingSolver.html#8001" class="Bound">equation</a><a id="8076" class="Symbol">)</a>
    <a id="8082" class="Keyword">where</a> <a id="8088" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a> <a id="8096" class="Symbol">→</a> <a id="8098" href="Agda.Builtin.Reflection.html#7540" class="Postulate">typeError</a> <a id="8108" class="Symbol">(</a><a id="8109" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="8116" class="String">&quot;Malformed call to solve.&quot;</a> <a id="8143" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="8176" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="8183" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a> <a id="8241" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="8274" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="8281" class="String">&quot;Instead: &quot;</a> <a id="8293" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="8326" href="Agda.Builtin.Reflection.html#7057" class="InductiveConstructor">termErr</a> <a id="8334" href="Tactic.RingSolver.html#7945" class="Bound">hole′</a> <a id="8340" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="8373" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="8375" class="Symbol">)</a>
  <a id="8379" href="Agda.Builtin.Reflection.html#7500" class="Postulate">unify</a> <a id="8385" href="Tactic.RingSolver.html#7821" class="Bound">hole</a> <a id="8390" class="Symbol">(</a><a id="8391" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="8395" class="Symbol">(</a><a id="8396" class="Keyword">quote</a> <a id="8402" href="Tactic.RingSolver.NonReflective.html#2889" class="Function">solve-fn</a><a id="8410" class="Symbol">)</a> <a id="8412" class="Symbol">(</a><a id="8413" href="Tactic.RingSolver.html#6342" class="Function">callSolver</a> <a id="8424" href="Tactic.RingSolver.html#7906" class="Bound">operatorNames</a> <a id="8438" href="Tactic.RingSolver.html#7985" class="Bound">variables</a> <a id="8448" href="Tactic.RingSolver.html#7997" class="Bound">k</a> <a id="8450" href="Tactic.RingSolver.html#8034" class="Bound">lhs</a> <a id="8454" href="Tactic.RingSolver.html#8040" class="Bound">rhs</a><a id="8457" class="Symbol">))</a>

<a id="8461" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="8469" href="Tactic.RingSolver.html#8469" class="Function">solve-∀</a> <a id="8477" class="Symbol">:</a> <a id="8479" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="8484" class="Symbol">→</a> <a id="8486" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="8491" class="Symbol">→</a> <a id="8493" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="8496" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a>
  <a id="8500" href="Tactic.RingSolver.html#8469" class="Function">solve-∀</a> <a id="8508" class="Symbol">=</a> <a id="8510" href="Tactic.RingSolver.html#7767" class="Function">solve-∀-macro</a>

<a id="8525" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="8607" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="8682" class="Comment">-- intermediate step. Call it like so:</a>
<a id="8721" class="Comment">--</a>
<a id="8724" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="8776" class="Comment">--   lemma₃ x y = begin</a>
<a id="8800" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="8859" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="8913" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="8944" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="8967" class="Comment">--</a>
<a id="8970" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="9037" class="Comment">-- ring implementation (as before).</a>
<a id="9073" class="Comment">--</a>
<a id="9076" class="Comment">-- One thing to note here is that we need to be able to infer *both* sides of</a>
<a id="9154" class="Comment">-- the equality, which the normal equaltional reasoning combinators don&#39;t let you</a>
<a id="9236" class="Comment">-- do. You&#39;ll need the combinators defined in Relation.Binary.Reasoning.Inference.</a>
<a id="9319" class="Comment">-- These are just as powerful as the others, but have slightly better inference properties.</a>

<a id="solve-macro"></a><a id="9412" href="Tactic.RingSolver.html#9412" class="Function">solve-macro</a> <a id="9424" class="Symbol">:</a> <a id="9426" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="9431" class="Symbol">→</a> <a id="9433" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="9438" class="Symbol">→</a> <a id="9440" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="9445" class="Symbol">→</a> <a id="9447" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="9450" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a>
<a id="9452" href="Tactic.RingSolver.html#9412" class="Function">solve-macro</a> <a id="9464" href="Tactic.RingSolver.html#9464" class="Bound">i</a> <a id="9466" href="Tactic.RingSolver.html#9466" class="Bound">ring</a> <a id="9471" href="Tactic.RingSolver.html#9471" class="Bound">hole</a> <a id="9476" class="Symbol">=</a> <a id="9478" class="Keyword">do</a>
  <a id="9483" href="Tactic.RingSolver.html#9483" class="Bound">ring′</a> <a id="9489" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="9491" href="Tactic.RingSolver.html#1601" class="Function">checkIsRing</a> <a id="9503" class="Symbol">(</a><a id="9504" href="Agda.Builtin.Reflection.html#4879" class="InductiveConstructor">def</a> <a id="9508" href="Tactic.RingSolver.html#9466" class="Bound">ring</a> <a id="9513" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="9515" class="Symbol">)</a>
  <a id="9519" href="Agda.Builtin.Reflection.html#8401" class="Postulate">commitTC</a>
  <a id="9530" class="Keyword">let</a> <a id="9534" class="Keyword">open</a> <a id="9539" href="Tactic.RingSolver.html#2069" class="Module">OverRing</a> <a id="9548" href="Tactic.RingSolver.html#9483" class="Bound">ring′</a>
  <a id="9556" href="Tactic.RingSolver.html#9556" class="Bound">operatorNames</a> <a id="9570" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="9572" href="Tactic.RingSolver.html#2732" class="Function">getRingOperatorNames</a>
  <a id="9595" href="Tactic.RingSolver.html#9595" class="Bound">listOfVariables′</a> <a id="9612" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="9614" href="Tactic.RingSolver.html#2410" class="Function">checkIsListOfVariables</a> <a id="9637" href="Tactic.RingSolver.html#9464" class="Bound">i</a>
  <a id="9641" href="Agda.Builtin.Reflection.html#8401" class="Postulate">commitTC</a>
  <a id="9652" href="Tactic.RingSolver.html#9652" class="Bound">hole′</a> <a id="9658" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="9660" href="Agda.Builtin.Reflection.html#7603" class="Postulate">inferType</a> <a id="9670" href="Tactic.RingSolver.html#9471" class="Bound">hole</a> <a id="9675" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">&gt;&gt;=</a> <a id="9679" href="Agda.Builtin.Reflection.html#7718" class="Postulate">reduce</a>
  <a id="9688" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="9693" href="Tactic.RingSolver.html#9693" class="Bound">vars′</a> <a id="9699" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="9701" href="Reflection.TCMonadSyntax.html#511" class="Function">pure</a> <a id="9706" class="Symbol">(</a><a id="9707" href="Tactic.RingSolver.html#1717" class="Function">getVariableIDs</a> <a id="9722" href="Tactic.RingSolver.html#9595" class="Bound">listOfVariables′</a><a id="9738" class="Symbol">)</a>
    <a id="9744" class="Keyword">where</a> <a id="9750" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a> <a id="9758" class="Symbol">→</a> <a id="9760" href="Agda.Builtin.Reflection.html#7540" class="Postulate">typeError</a> <a id="9770" class="Symbol">(</a><a id="9771" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="9778" class="String">&quot;Malformed call to solve.&quot;</a> <a id="9805" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="9838" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="9845" class="String">&quot;First argument should be a list of free variables.&quot;</a> <a id="9898" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="9931" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="9938" class="String">&quot;Instead: &quot;</a> <a id="9950" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="9983" href="Agda.Builtin.Reflection.html#7057" class="InductiveConstructor">termErr</a> <a id="9991" href="Tactic.RingSolver.html#9595" class="Bound">listOfVariables′</a> <a id="10008" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="10041" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="10043" class="Symbol">)</a>
  <a id="10047" href="Data.Maybe.Base.html#892" class="InductiveConstructor">just</a> <a id="10052" class="Symbol">(</a><a id="10053" href="Tactic.RingSolver.html#10053" class="Bound">lhs</a> <a id="10057" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="10059" href="Tactic.RingSolver.html#10059" class="Bound">rhs</a> <a id="10063" href="Data.Vec.Base.html#1014" class="InductiveConstructor Operator">∷</a> <a id="10065" href="Data.Vec.Base.html#995" class="InductiveConstructor">[]</a><a id="10067" class="Symbol">)</a> <a id="10069" href="Reflection.TCMonadSyntax.html#670" class="Function Operator">←</a> <a id="10071" href="Reflection.TCMonadSyntax.html#511" class="Function">pure</a> <a id="10076" class="Symbol">(</a><a id="10077" href="Tactic.RingSolver.Core.ReflectionHelp.html#1412" class="Function">getArgs</a> <a id="10085" class="Number">2</a> <a id="10087" href="Tactic.RingSolver.html#9652" class="Bound">hole′</a><a id="10092" class="Symbol">)</a>
    <a id="10098" class="Keyword">where</a> <a id="10104" href="Data.Maybe.Base.html#872" class="InductiveConstructor">nothing</a> <a id="10112" class="Symbol">→</a> <a id="10114" href="Agda.Builtin.Reflection.html#7540" class="Postulate">typeError</a> <a id="10124" class="Symbol">(</a><a id="10125" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="10132" class="String">&quot;Malformed call to solve.&quot;</a> <a id="10159" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="10192" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="10199" class="String">&quot;First argument should be a list of free variables.&quot;</a> <a id="10252" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="10285" href="Agda.Builtin.Reflection.html#7026" class="InductiveConstructor">strErr</a> <a id="10292" class="String">&quot;Instead: &quot;</a> <a id="10304" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="10337" href="Agda.Builtin.Reflection.html#7057" class="InductiveConstructor">termErr</a> <a id="10345" href="Tactic.RingSolver.html#9652" class="Bound">hole′</a> <a id="10351" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a>
                               <a id="10384" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="10386" class="Symbol">)</a>
  <a id="10390" href="Agda.Builtin.Reflection.html#7500" class="Postulate">unify</a> <a id="10396" href="Tactic.RingSolver.html#9471" class="Bound">hole</a> <a id="10401" class="Symbol">(</a><a id="10402" href="Tactic.RingSolver.html#6762" class="Function">constructSoln</a> <a id="10416" href="Tactic.RingSolver.html#9556" class="Bound">operatorNames</a> <a id="10430" class="Symbol">(</a><a id="10431" href="Data.List.Base.html#4297" class="Function">List.length</a> <a id="10443" href="Tactic.RingSolver.html#9693" class="Bound">vars′</a><a id="10448" class="Symbol">)</a> <a id="10450" href="Tactic.RingSolver.html#9693" class="Bound">vars′</a> <a id="10456" href="Tactic.RingSolver.html#10053" class="Bound">lhs</a> <a id="10460" href="Tactic.RingSolver.html#10059" class="Bound">rhs</a><a id="10463" class="Symbol">)</a>

<a id="10466" class="Keyword">macro</a>
  <a id="solve"></a><a id="10474" href="Tactic.RingSolver.html#10474" class="Function">solve</a> <a id="10480" class="Symbol">:</a> <a id="10482" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="10487" class="Symbol">→</a> <a id="10489" href="Agda.Builtin.Reflection.html#435" class="Postulate">Name</a> <a id="10494" class="Symbol">→</a> <a id="10496" href="Agda.Builtin.Reflection.html#4722" class="Datatype">Term</a> <a id="10501" class="Symbol">→</a> <a id="10503" href="Agda.Builtin.Reflection.html#7327" class="Postulate">TC</a> <a id="10506" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a>
  <a id="10510" href="Tactic.RingSolver.html#10474" class="Function">solve</a> <a id="10516" class="Symbol">=</a> <a id="10518" href="Tactic.RingSolver.html#9412" class="Function">solve-macro</a>
</pre></body></html>