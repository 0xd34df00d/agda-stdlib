<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.List</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Documentation for the List type</a>
<a id="141" class="Comment">------------------------------------------------------------------------</a>

<a id="215" class="Symbol">{-#</a> <a id="219" class="Keyword">OPTIONS</a> <a id="227" class="Pragma">--warning</a> <a id="237" class="Pragma">noMissingDefinitions</a> <a id="258" class="Symbol">#-}</a>

<a id="263" class="Keyword">module</a> <a id="270" href="README.Data.List.html" class="Module">README.Data.List</a> <a id="287" class="Keyword">where</a>

<a id="294" class="Keyword">open</a> <a id="299" class="Keyword">import</a> <a id="306" href="Algebra.Structures.html" class="Module">Algebra.Structures</a>
<a id="325" class="Keyword">open</a> <a id="330" class="Keyword">import</a> <a id="337" href="Data.Char.html" class="Module">Data.Char</a>
<a id="347" class="Keyword">open</a> <a id="352" class="Keyword">import</a> <a id="359" href="Data.Char.Properties.html" class="Module">Data.Char.Properties</a> <a id="380" class="Symbol">as</a> <a id="383" class="Module">CharProp</a> <a id="392" class="Keyword">hiding</a> <a id="399" class="Symbol">(</a><a id="400" href="Data.Char.Properties.html#1913" class="Function">setoid</a><a id="406" class="Symbol">)</a>
<a id="408" class="Keyword">open</a> <a id="413" class="Keyword">import</a> <a id="420" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="429" class="Keyword">open</a> <a id="434" class="Keyword">import</a> <a id="441" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="461" class="Symbol">as</a> <a id="464" class="Module">NatProp</a>
<a id="472" class="Keyword">open</a> <a id="477" class="Keyword">import</a> <a id="484" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="524" class="Keyword">using</a> <a id="530" class="Symbol">(</a><a id="531" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="534" class="Symbol">;</a> <a id="536" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="540" class="Symbol">;</a> <a id="542" href="Relation.Binary.PropositionalEquality.Core.html#913" class="Function">sym</a><a id="545" class="Symbol">;</a> <a id="547" href="Relation.Binary.PropositionalEquality.Core.html#1084" class="Function">cong</a><a id="551" class="Symbol">;</a> <a id="553" href="Relation.Binary.PropositionalEquality.html#1508" class="Function">setoid</a><a id="559" class="Symbol">)</a>

<a id="562" class="Comment">------------------------------------------------------------------------</a>
<a id="635" class="Comment">-- 1. Basics</a>
<a id="648" class="Comment">------------------------------------------------------------------------</a>
<a id="721" class="Comment">-- The `List` datatype is exported by the following file:</a>

<a id="780" class="Keyword">open</a> <a id="785" class="Keyword">import</a> <a id="792" href="Data.List.html" class="Module">Data.List</a>

<a id="803" class="Keyword">module</a> <a id="Basics"></a><a id="810" href="README.Data.List.html#810" class="Module">Basics</a> <a id="817" class="Keyword">where</a>

  <a id="826" class="Comment">-- Lists are built using the &quot;[]&quot; and &quot;_∷_&quot; constructors.</a>

  <a id="Basics.list₁"></a><a id="887" href="README.Data.List.html#887" class="Function">list₁</a> <a id="893" class="Symbol">:</a> <a id="895" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="900" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="904" href="README.Data.List.html#887" class="Function">list₁</a> <a id="910" class="Symbol">=</a> <a id="912" class="Number">3</a> <a id="914" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="916" class="Number">1</a> <a id="918" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="920" class="Number">2</a> <a id="922" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="924" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>

  <a id="930" class="Comment">-- Basic operations over lists are also exported by the same file.</a>

  <a id="Basics.lem₁"></a><a id="1000" href="README.Data.List.html#1000" class="Function">lem₁</a> <a id="1005" class="Symbol">:</a> <a id="1007" href="Data.List.Base.html#4024" class="Function">sum</a> <a id="1011" href="README.Data.List.html#887" class="Function">list₁</a> <a id="1017" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1019" class="Number">6</a>
  <a id="1023" href="README.Data.List.html#1000" class="Function">lem₁</a> <a id="1028" class="Symbol">=</a> <a id="1030" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₂"></a><a id="1038" href="README.Data.List.html#1038" class="Function">lem₂</a> <a id="1043" class="Symbol">:</a> <a id="1045" href="Data.List.Base.html#1304" class="Function">map</a> <a id="1049" class="Symbol">(</a><a id="1050" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+</a> <a id="1053" class="Number">2</a><a id="1054" class="Symbol">)</a> <a id="1056" href="README.Data.List.html#887" class="Function">list₁</a> <a id="1062" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1064" class="Number">5</a> <a id="1066" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1068" class="Number">3</a> <a id="1070" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1072" class="Number">4</a> <a id="1074" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1076" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1081" href="README.Data.List.html#1038" class="Function">lem₂</a> <a id="1086" class="Symbol">=</a> <a id="1088" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₃"></a><a id="1096" href="README.Data.List.html#1096" class="Function">lem₃</a> <a id="1101" class="Symbol">:</a> <a id="1103" href="Data.List.Base.html#6458" class="Function">take</a> <a id="1108" class="Number">2</a> <a id="1110" href="README.Data.List.html#887" class="Function">list₁</a> <a id="1116" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1118" class="Number">3</a> <a id="1120" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1122" class="Number">1</a> <a id="1124" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1126" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1131" href="README.Data.List.html#1096" class="Function">lem₃</a> <a id="1136" class="Symbol">=</a> <a id="1138" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₄"></a><a id="1146" href="README.Data.List.html#1146" class="Function">lem₄</a> <a id="1151" class="Symbol">:</a> <a id="1153" href="Data.List.Base.html#8564" class="Function">reverse</a> <a id="1161" href="README.Data.List.html#887" class="Function">list₁</a> <a id="1167" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1169" class="Number">2</a> <a id="1171" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1173" class="Number">1</a> <a id="1175" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1177" class="Number">3</a> <a id="1179" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1181" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1186" href="README.Data.List.html#1146" class="Function">lem₄</a> <a id="1191" class="Symbol">=</a> <a id="1193" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₅"></a><a id="1201" href="README.Data.List.html#1201" class="Function">lem₅</a> <a id="1206" class="Symbol">:</a> <a id="1208" href="README.Data.List.html#887" class="Function">list₁</a> <a id="1214" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="1217" href="README.Data.List.html#887" class="Function">list₁</a> <a id="1223" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1225" class="Number">3</a> <a id="1227" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1229" class="Number">1</a> <a id="1231" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1233" class="Number">2</a> <a id="1235" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1237" class="Number">3</a> <a id="1239" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1241" class="Number">1</a> <a id="1243" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1245" class="Number">2</a> <a id="1247" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1249" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1254" href="README.Data.List.html#1201" class="Function">lem₅</a> <a id="1259" class="Symbol">=</a> <a id="1261" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="1269" class="Comment">-- Various properties of these operations can be found in:</a>

  <a id="1331" class="Keyword">open</a> <a id="1336" class="Keyword">import</a> <a id="1343" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>

  <a id="Basics.lem₆"></a><a id="1367" href="README.Data.List.html#1367" class="Function">lem₆</a> <a id="1372" class="Symbol">:</a> <a id="1374" class="Symbol">∀</a> <a id="1376" href="README.Data.List.html#1376" class="Bound">n</a> <a id="1378" class="Symbol">(</a><a id="1379" href="README.Data.List.html#1379" class="Bound">xs</a> <a id="1382" class="Symbol">:</a> <a id="1384" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1389" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1390" class="Symbol">)</a> <a id="1392" class="Symbol">→</a> <a id="1394" href="Data.List.Base.html#6458" class="Function">take</a> <a id="1399" href="README.Data.List.html#1376" class="Bound">n</a> <a id="1401" href="README.Data.List.html#1379" class="Bound">xs</a> <a id="1404" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="1407" href="Data.List.Base.html#6578" class="Function">drop</a> <a id="1412" href="README.Data.List.html#1376" class="Bound">n</a> <a id="1414" href="README.Data.List.html#1379" class="Bound">xs</a> <a id="1417" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1419" href="README.Data.List.html#1379" class="Bound">xs</a>
  <a id="1424" href="README.Data.List.html#1367" class="Function">lem₆</a> <a id="1429" class="Symbol">=</a> <a id="1431" href="Data.List.Properties.html#23214" class="Function">take++drop</a>

  <a id="Basics.lem₇"></a><a id="1445" href="README.Data.List.html#1445" class="Function">lem₇</a> <a id="1450" class="Symbol">:</a> <a id="1452" class="Symbol">∀</a> <a id="1454" class="Symbol">(</a><a id="1455" href="README.Data.List.html#1455" class="Bound">xs</a> <a id="1458" class="Symbol">:</a> <a id="1460" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1465" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1466" class="Symbol">)</a> <a id="1468" class="Symbol">→</a> <a id="1470" href="Data.List.Base.html#8564" class="Function">reverse</a> <a id="1478" class="Symbol">(</a><a id="1479" href="Data.List.Base.html#8564" class="Function">reverse</a> <a id="1487" href="README.Data.List.html#1455" class="Bound">xs</a><a id="1489" class="Symbol">)</a> <a id="1491" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1493" href="README.Data.List.html#1455" class="Bound">xs</a>
  <a id="1498" href="README.Data.List.html#1445" class="Function">lem₇</a> <a id="1503" class="Symbol">=</a> <a id="1505" href="Data.List.Properties.html#27788" class="Function">reverse-involutive</a>

  <a id="Basics.lem₈"></a><a id="1527" href="README.Data.List.html#1527" class="Function">lem₈</a> <a id="1532" class="Symbol">:</a> <a id="1534" class="Symbol">∀</a> <a id="1536" class="Symbol">(</a><a id="1537" href="README.Data.List.html#1537" class="Bound">xs</a> <a id="1540" href="README.Data.List.html#1540" class="Bound">ys</a> <a id="1543" href="README.Data.List.html#1543" class="Bound">zs</a> <a id="1546" class="Symbol">:</a> <a id="1548" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1553" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1554" class="Symbol">)</a> <a id="1556" class="Symbol">→</a> <a id="1558" class="Symbol">(</a><a id="1559" href="README.Data.List.html#1537" class="Bound">xs</a> <a id="1562" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="1565" href="README.Data.List.html#1540" class="Bound">ys</a><a id="1567" class="Symbol">)</a> <a id="1569" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="1572" href="README.Data.List.html#1543" class="Bound">zs</a> <a id="1575" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1577" href="README.Data.List.html#1537" class="Bound">xs</a> <a id="1580" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="1583" class="Symbol">(</a><a id="1584" href="README.Data.List.html#1540" class="Bound">ys</a> <a id="1587" href="Data.List.Base.html#1570" class="Function Operator">++</a> <a id="1590" href="README.Data.List.html#1543" class="Bound">zs</a><a id="1592" class="Symbol">)</a>
  <a id="1596" href="README.Data.List.html#1527" class="Function">lem₈</a> <a id="1601" class="Symbol">=</a> <a id="1603" href="Data.List.Properties.html#4770" class="Function">++-assoc</a>

<a id="1613" class="Comment">------------------------------------------------------------------------</a>
<a id="1686" class="Comment">-- 2. Binary relations over lists</a>
<a id="1720" class="Comment">------------------------------------------------------------------------</a>

<a id="1794" class="Comment">-- All binary relations over lists are found in the folder</a>
<a id="1853" class="Comment">-- `Data.List.Relation.Binary`.</a>

<a id="1886" class="Comment">------------------------------------------------------------------------</a>
<a id="1959" class="Comment">-- Pointwise</a>

<a id="1973" class="Keyword">module</a> <a id="PointwiseExplanation"></a><a id="1980" href="README.Data.List.html#1980" class="Module">PointwiseExplanation</a> <a id="2001" class="Keyword">where</a>

  <a id="2010" class="Comment">-- One of the most basic ways to form a binary relation between two</a>
  <a id="2080" class="Comment">-- lists of type `List A`, given a binary relation over `A`, is to say</a>
  <a id="2153" class="Comment">-- that two lists are related if:</a>
  <a id="2189" class="Comment">--   i) the first elements in the lists are related</a>
  <a id="2243" class="Comment">--   ii) the second elements in the lists are related</a>
  <a id="2299" class="Comment">--   iii) the third elements in the lists are related etc.</a>
  <a id="2360" class="Comment">--</a>
  <a id="2365" class="Comment">-- A formalisation of this &quot;pointwise&quot; lifting of a relation to lists</a>
  <a id="2437" class="Comment">-- is found in:</a>

  <a id="2456" class="Keyword">open</a> <a id="2461" class="Keyword">import</a> <a id="2468" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a>

  <a id="2507" class="Comment">-- The same syntax to construct a list (`[]` &amp; `_∷_`) is used to</a>
  <a id="2574" class="Comment">-- construct proofs for the `Pointwise` relation. For example if you</a>
  <a id="2645" class="Comment">-- want to prove that one list is strictly less than another list:</a>

  <a id="PointwiseExplanation.lem₁"></a><a id="2715" href="README.Data.List.html#2715" class="Function">lem₁</a> <a id="2720" class="Symbol">:</a> <a id="2722" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a> <a id="2732" href="Data.Nat.Base.html#1076" class="Function Operator">_&lt;_</a> <a id="2736" class="Symbol">(</a><a id="2737" class="Number">0</a> <a id="2739" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2741" class="Number">2</a> <a id="2743" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2745" class="Number">1</a> <a id="2747" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2749" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2751" class="Symbol">)</a> <a id="2753" class="Symbol">(</a><a id="2754" class="Number">1</a> <a id="2756" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2758" class="Number">4</a> <a id="2760" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2762" class="Number">2</a> <a id="2764" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2766" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2768" class="Symbol">)</a>
  <a id="2772" href="README.Data.List.html#2715" class="Function">lem₁</a> <a id="2777" class="Symbol">=</a> <a id="2779" href="README.Data.List.html#2814" class="Function">0&lt;1</a> <a id="2783" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="2785" href="README.Data.List.html#2832" class="Function">2&lt;4</a> <a id="2789" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="2791" href="README.Data.List.html#2862" class="Function">1&lt;2</a> <a id="2795" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="2797" href="Data.List.Relation.Binary.Pointwise.html#1090" class="InductiveConstructor">[]</a>
    <a id="2804" class="Keyword">where</a>
    <a id="2814" href="README.Data.List.html#2814" class="Function">0&lt;1</a> <a id="2818" class="Symbol">=</a> <a id="2820" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2824" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a>
    <a id="2832" href="README.Data.List.html#2832" class="Function">2&lt;4</a> <a id="2836" class="Symbol">=</a> <a id="2838" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2847" class="Symbol">(</a><a id="2848" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2852" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="2855" class="Symbol">))</a>
    <a id="2862" href="README.Data.List.html#2862" class="Function">1&lt;2</a> <a id="2866" class="Symbol">=</a> <a id="2868" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2872" href="README.Data.List.html#2814" class="Function">0&lt;1</a>

  <a id="2879" class="Comment">-- Lists that are related by `Pointwise` must be of the same length.</a>
  <a id="2950" class="Comment">-- For example:</a>

  <a id="2969" class="Keyword">open</a> <a id="2974" class="Keyword">import</a> <a id="2981" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="2998" class="Keyword">using</a> <a id="3004" class="Symbol">(</a><a id="3005" href="Relation.Nullary.html#500" class="Function Operator">¬_</a><a id="3007" class="Symbol">)</a>

  <a id="PointwiseExplanation.lem₂"></a><a id="3012" href="README.Data.List.html#3012" class="Function">lem₂</a> <a id="3017" class="Symbol">:</a> <a id="3019" href="Relation.Nullary.html#500" class="Function Operator">¬</a> <a id="3021" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a> <a id="3031" href="Data.Nat.Base.html#1076" class="Function Operator">_&lt;_</a> <a id="3035" class="Symbol">(</a><a id="3036" class="Number">0</a> <a id="3038" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3040" class="Number">2</a> <a id="3042" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3044" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3046" class="Symbol">)</a> <a id="3048" class="Symbol">(</a><a id="3049" class="Number">1</a> <a id="3051" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3053" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3055" class="Symbol">)</a>
  <a id="3059" href="README.Data.List.html#3012" class="Function">lem₂</a> <a id="3064" class="Symbol">(</a><a id="3065" href="README.Data.List.html#3065" class="Bound">0&lt;1</a> <a id="3069" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="3071" class="Symbol">())</a>

<a id="3076" class="Comment">------------------------------------------------------------------------</a>
<a id="3149" class="Comment">-- Equality</a>

<a id="3162" class="Keyword">module</a> <a id="EqualityExplanation"></a><a id="3169" href="README.Data.List.html#3169" class="Module">EqualityExplanation</a> <a id="3189" class="Keyword">where</a>

  <a id="3198" class="Comment">-- There are many different options for what it means for two</a>
  <a id="3262" class="Comment">-- different lists of type `List A` to be &quot;equal&quot;. We will initially</a>
  <a id="3333" class="Comment">-- consider notions of equality that require the list elements to be</a>
  <a id="3404" class="Comment">-- in the same order and later discuss other types of equality.</a>

  <a id="3471" class="Comment">-- The most basic option in the former case is simply to use</a>
  <a id="3534" class="Comment">-- propositional equality `_≡_` over lists:</a>

  <a id="3581" class="Keyword">open</a> <a id="3586" class="Keyword">import</a> <a id="3593" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
    <a id="3635" class="Keyword">using</a> <a id="3641" class="Symbol">(</a><a id="3642" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="3645" class="Symbol">;</a> <a id="3647" href="Relation.Binary.PropositionalEquality.Core.html#913" class="Function">sym</a><a id="3650" class="Symbol">;</a> <a id="3652" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="3656" class="Symbol">)</a>

  <a id="EqualityExplanation.lem₁"></a><a id="3661" href="README.Data.List.html#3661" class="Function">lem₁</a> <a id="3666" class="Symbol">:</a> <a id="3668" class="Number">1</a> <a id="3670" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3672" class="Number">2</a> <a id="3674" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3676" class="Number">3</a> <a id="3678" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3680" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="3683" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3685" class="Number">1</a> <a id="3687" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3689" class="Number">2</a> <a id="3691" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3693" class="Number">3</a> <a id="3695" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3697" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="3702" href="README.Data.List.html#3661" class="Function">lem₁</a> <a id="3707" class="Symbol">=</a> <a id="3709" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="3717" class="Comment">-- However propositional equality is only suitable when we want to</a>
  <a id="3786" class="Comment">-- use propositional equality to compare the individual elements.</a>
  <a id="3854" class="Comment">-- Although a contrived example, consider trying to prove the</a>
  <a id="3918" class="Comment">-- equality of two lists of the type `List (ℕ → ℕ)`:</a>

  <a id="EqualityExplanation.lem₂"></a><a id="3974" href="README.Data.List.html#3974" class="Postulate">lem₂</a> <a id="3979" class="Symbol">:</a> <a id="3981" class="Symbol">(λ</a> <a id="3984" href="README.Data.List.html#3984" class="Bound">x</a> <a id="3986" class="Symbol">→</a> <a id="3988" class="Number">2</a> <a id="3990" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="3992" href="README.Data.List.html#3984" class="Bound">x</a> <a id="3994" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3996" class="Number">2</a><a id="3997" class="Symbol">)</a> <a id="3999" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4001" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="4004" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4006" class="Symbol">(λ</a> <a id="4009" href="README.Data.List.html#4009" class="Bound">x</a> <a id="4011" class="Symbol">→</a> <a id="4013" class="Number">2</a> <a id="4015" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="4017" class="Symbol">(</a><a id="4018" href="README.Data.List.html#4009" class="Bound">x</a> <a id="4020" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4022" class="Number">1</a><a id="4023" class="Symbol">))</a> <a id="4026" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4028" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>

  <a id="4034" class="Comment">-- In such a case it is impossible to prove the two lists equal with</a>
  <a id="4105" class="Comment">-- refl as the two functions are not propositionally equal. In the</a>
  <a id="4174" class="Comment">-- absence of postulating function extensionality (see README.Axioms),</a>
  <a id="4247" class="Comment">-- the most common definition of function equality is to say that two</a>
  <a id="4319" class="Comment">-- functions are equal if their outputs are always propositionally</a>
  <a id="4388" class="Comment">-- equal for any input. This notion of function equality `_≗_` is</a>
  <a id="4456" class="Comment">-- found in:</a>

  <a id="4472" class="Keyword">open</a> <a id="4477" class="Keyword">import</a> <a id="4484" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="4522" class="Keyword">using</a> <a id="4528" class="Symbol">(</a><a id="4529" href="Relation.Binary.PropositionalEquality.html#2429" class="Function Operator">_≗_</a><a id="4532" class="Symbol">)</a>

  <a id="4537" class="Comment">-- We now want to use the `Pointwise` relation to say that the two</a>
  <a id="4606" class="Comment">-- lists are equal if their elements are pointwise equal with resepct</a>
  <a id="4678" class="Comment">-- to `_≗_`. However instead of using the pointwise module directly</a>
  <a id="4748" class="Comment">-- to write:</a>

  <a id="4764" class="Keyword">open</a> <a id="4769" class="Keyword">import</a> <a id="4776" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a> <a id="4812" class="Keyword">using</a> <a id="4818" class="Symbol">(</a><a id="4819" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a><a id="4828" class="Symbol">)</a>

  <a id="EqualityExplanation.lem₃"></a><a id="4833" href="README.Data.List.html#4833" class="Postulate">lem₃</a> <a id="4838" class="Symbol">:</a> <a id="4840" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a> <a id="4850" href="Relation.Binary.PropositionalEquality.html#2429" class="Function Operator">_≗_</a> <a id="4854" class="Symbol">((λ</a> <a id="4858" href="README.Data.List.html#4858" class="Bound">x</a> <a id="4860" class="Symbol">→</a> <a id="4862" href="README.Data.List.html#4858" class="Bound">x</a> <a id="4864" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4866" class="Number">1</a><a id="4867" class="Symbol">)</a> <a id="4869" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4871" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4873" class="Symbol">)</a> <a id="4875" class="Symbol">((λ</a> <a id="4879" href="README.Data.List.html#4879" class="Bound">x</a> <a id="4881" class="Symbol">→</a> <a id="4883" href="README.Data.List.html#4879" class="Bound">x</a> <a id="4885" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4887" class="Number">2</a> <a id="4889" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="4891" class="Number">1</a><a id="4892" class="Symbol">)</a> <a id="4894" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4896" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4898" class="Symbol">)</a>

  <a id="4903" class="Comment">-- the library provides some nicer wrappers and infix notation in the</a>
  <a id="4975" class="Comment">-- folder &quot;Data.List.Relation.Binary.Equality&quot;.</a>

  <a id="5026" class="Comment">-- Within this folder there are four different modules.</a>

  <a id="5085" class="Keyword">import</a> <a id="5092" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">Data.List.Relation.Binary.Equality.Setoid</a>           <a id="5144" class="Symbol">as</a> <a id="5147" class="Module">SetoidEq</a>
  <a id="5158" class="Keyword">import</a> <a id="5165" href="Data.List.Relation.Binary.Equality.DecSetoid.html" class="Module">Data.List.Relation.Binary.Equality.DecSetoid</a>        <a id="5217" class="Symbol">as</a> <a id="5220" class="Module">DecSetoidEq</a>
  <a id="5234" class="Keyword">import</a> <a id="5241" href="Data.List.Relation.Binary.Equality.Propositional.html" class="Module">Data.List.Relation.Binary.Equality.Propositional</a>    <a id="5293" class="Symbol">as</a> <a id="5296" class="Module">PropEq</a>
  <a id="5305" class="Keyword">import</a> <a id="5312" href="Data.List.Relation.Binary.Equality.DecPropositional.html" class="Module">Data.List.Relation.Binary.Equality.DecPropositional</a> <a id="5364" class="Symbol">as</a> <a id="5367" class="Module">DecPropEq</a>

  <a id="5380" class="Comment">-- Which one should be used depends on whether the underlying equality</a>
  <a id="5453" class="Comment">-- over &quot;A&quot; is:</a>
  <a id="5471" class="Comment">--   i)  propositional or setoid-based</a>
  <a id="5512" class="Comment">--   ii) decidable.</a>

  <a id="5535" class="Comment">-- Each of the modules except `PropEq` are designed to be opened with a</a>
  <a id="5609" class="Comment">-- module parameter. This is to avoid having to specify the underlying</a>
  <a id="5682" class="Comment">-- equality relation or the decidability proofs every time you use the</a>
  <a id="5755" class="Comment">-- list equality.</a>

  <a id="5776" class="Comment">-- In our example function equality is not decidable and not propositional</a>
  <a id="5853" class="Comment">-- and so we want to use the `SetoidEq` module. This requires a proof that</a>
  <a id="5930" class="Comment">-- the `_≗_` relation forms a setoid over functions of the type `ℕ → ℕ`.</a>
  <a id="6005" class="Comment">-- This is found in:</a>

  <a id="6029" class="Keyword">open</a> <a id="6034" class="Keyword">import</a> <a id="6041" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="6079" class="Keyword">using</a> <a id="6085" class="Symbol">(</a><a id="6086" href="Relation.Binary.PropositionalEquality.html#2309" class="Function Operator">_→-setoid_</a><a id="6096" class="Symbol">)</a>

  <a id="6101" class="Comment">-- The `SetoidEq` module should therefore be opened as follows:</a>

  <a id="6168" class="Keyword">open</a> <a id="6173" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">SetoidEq</a> <a id="6182" class="Symbol">(</a><a id="6183" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="6185" href="Relation.Binary.PropositionalEquality.html#2309" class="Function Operator">→-setoid</a> <a id="6194" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="6195" class="Symbol">)</a>

  <a id="6200" class="Comment">-- All four equality modules provide an infix operator `_≋_` for the</a>
  <a id="6271" class="Comment">-- new equality relation over lists. The type of `lem₃` can therefore</a>
  <a id="6343" class="Comment">-- be rewritten as:</a>

  <a id="EqualityExplanation.lem₄"></a><a id="6366" href="README.Data.List.html#6366" class="Function">lem₄</a> <a id="6371" class="Symbol">:</a> <a id="6373" class="Symbol">(λ</a> <a id="6376" href="README.Data.List.html#6376" class="Bound">x</a> <a id="6378" class="Symbol">→</a> <a id="6380" href="README.Data.List.html#6376" class="Bound">x</a> <a id="6382" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6384" class="Number">1</a><a id="6385" class="Symbol">)</a> <a id="6387" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6389" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="6392" href="Data.List.Relation.Binary.Equality.Setoid.html#792" class="Function Operator">≋</a> <a id="6394" class="Symbol">(λ</a> <a id="6397" href="README.Data.List.html#6397" class="Bound">x</a> <a id="6399" class="Symbol">→</a> <a id="6401" href="README.Data.List.html#6397" class="Bound">x</a> <a id="6403" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6405" class="Number">2</a> <a id="6407" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="6409" class="Number">1</a><a id="6410" class="Symbol">)</a> <a id="6412" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6414" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="6419" href="README.Data.List.html#6366" class="Function">lem₄</a> <a id="6424" class="Symbol">=</a> <a id="6426" href="README.Data.List.html#6457" class="Function">2x+2≗2[x+1]</a> <a id="6438" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="6440" href="Data.List.Relation.Binary.Pointwise.html#1090" class="InductiveConstructor">[]</a>
    <a id="6447" class="Keyword">where</a>
    <a id="6457" href="README.Data.List.html#6457" class="Function">2x+2≗2[x+1]</a> <a id="6469" class="Symbol">:</a> <a id="6471" class="Symbol">(λ</a> <a id="6474" href="README.Data.List.html#6474" class="Bound">x</a> <a id="6476" class="Symbol">→</a> <a id="6478" href="README.Data.List.html#6474" class="Bound">x</a> <a id="6480" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6482" class="Number">1</a><a id="6483" class="Symbol">)</a> <a id="6485" href="Relation.Binary.PropositionalEquality.html#2429" class="Function Operator">≗</a> <a id="6487" class="Symbol">(λ</a> <a id="6490" href="README.Data.List.html#6490" class="Bound">x</a> <a id="6492" class="Symbol">→</a> <a id="6494" href="README.Data.List.html#6490" class="Bound">x</a> <a id="6496" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6498" class="Number">2</a> <a id="6500" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="6502" class="Number">1</a><a id="6503" class="Symbol">)</a>
    <a id="6509" href="README.Data.List.html#6457" class="Function">2x+2≗2[x+1]</a> <a id="6521" href="README.Data.List.html#6521" class="Bound">x</a> <a id="6523" class="Symbol">=</a> <a id="6525" href="Relation.Binary.PropositionalEquality.Core.html#913" class="Function">sym</a> <a id="6529" class="Symbol">(</a><a id="6530" href="Data.Nat.Properties.html#37103" class="Function">+-∸-assoc</a> <a id="6540" href="README.Data.List.html#6521" class="Bound">x</a> <a id="6542" class="Symbol">(</a><a id="6543" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="6547" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="6550" class="Symbol">))</a>

  <a id="6556" class="Comment">-- The modules also provide proofs that the `_≋_` relation is a</a>
  <a id="6622" class="Comment">-- setoid in its own right and therefore is reflexive, symmetric,</a>
  <a id="6690" class="Comment">-- transitive:</a>

  <a id="EqualityExplanation.lem₅"></a><a id="6708" href="README.Data.List.html#6708" class="Function">lem₅</a> <a id="6713" class="Symbol">:</a> <a id="6715" class="Symbol">(λ</a> <a id="6718" href="README.Data.List.html#6718" class="Bound">x</a> <a id="6720" class="Symbol">→</a> <a id="6722" class="Number">2</a> <a id="6724" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="6726" href="README.Data.List.html#6718" class="Bound">x</a> <a id="6728" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6730" class="Number">2</a><a id="6731" class="Symbol">)</a> <a id="6733" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6735" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="6738" href="Data.List.Relation.Binary.Equality.Setoid.html#792" class="Function Operator">≋</a> <a id="6740" class="Symbol">(λ</a> <a id="6743" href="README.Data.List.html#6743" class="Bound">x</a> <a id="6745" class="Symbol">→</a> <a id="6747" class="Number">2</a> <a id="6749" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="6751" href="README.Data.List.html#6743" class="Bound">x</a> <a id="6753" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6755" class="Number">2</a><a id="6756" class="Symbol">)</a> <a id="6758" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6760" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="6765" href="README.Data.List.html#6708" class="Function">lem₅</a> <a id="6770" class="Symbol">=</a> <a id="6772" href="Data.List.Relation.Binary.Equality.Setoid.html#979" class="Function">≋-refl</a>

  <a id="6782" class="Comment">-- If we could prove that `_≗_` forms a `DecSetoid` then we could use</a>
  <a id="6854" class="Comment">-- the module `DecSetoidEq` instead. This exports everything from</a>
  <a id="6922" class="Comment">-- `SetoidEq` as well as the additional proof `_≋?_` that the list</a>
  <a id="6991" class="Comment">-- equality is decidable.</a>

  <a id="7020" class="Comment">-- This pattern of four modules for each of the four different types</a>
  <a id="7091" class="Comment">-- of equality is repeated throughout the library (e.g. see the</a>
  <a id="7157" class="Comment">-- `Membership` subheading below). Note that in this case the modules</a>
  <a id="7229" class="Comment">-- `PropEq` and `DecPropEq` are not very useful as if two lists are</a>
  <a id="7299" class="Comment">-- pointwise propositionally equal they are necessarily</a>
  <a id="7357" class="Comment">-- propositionally equal (and vice-versa). There are proofs of this</a>
  <a id="7427" class="Comment">-- fact exported by `PropEq` and `DecPropEq`. Although, these two</a>
  <a id="7495" class="Comment">-- types of list equality are not very useful in practice, they are</a>
  <a id="7565" class="Comment">-- included for completeness&#39;s sake.</a>

<a id="7603" class="Comment">------------------------------------------------------------------------</a>
<a id="7676" class="Comment">-- Permutations</a>

<a id="7693" class="Keyword">module</a> <a id="PermutationExplanation"></a><a id="7700" href="README.Data.List.html#7700" class="Module">PermutationExplanation</a> <a id="7723" class="Keyword">where</a>

  <a id="7732" class="Comment">-- Alternatively you might consider two lists to be equal if they</a>
  <a id="7800" class="Comment">-- contain the same elements regardless of the order of the elements.</a>
  <a id="7872" class="Comment">-- This is known as either &quot;set equality&quot; or a &quot;permutation&quot;.</a>

  <a id="7937" class="Comment">-- The easiest-to-use formalisation of this relation is found in the</a>
  <a id="8008" class="Comment">-- module:</a>

  <a id="8022" class="Keyword">open</a> <a id="8027" class="Keyword">import</a> <a id="8034" href="Data.List.Relation.Binary.Permutation.Inductive.html" class="Module">Data.List.Relation.Binary.Permutation.Inductive</a>

  <a id="8085" class="Comment">-- The permutation relation is written as `_↭_` and has four</a>
  <a id="8148" class="Comment">-- constructors. The first `refl` says that a list is always</a>
  <a id="8211" class="Comment">-- a permutation of itself, the second `prep` says that if the</a>
  <a id="8276" class="Comment">-- heads of the lists are the same they can be skipped, the third</a>
  <a id="8344" class="Comment">-- `swap` says that the first two elements of the lists can be</a>
  <a id="8409" class="Comment">-- swapped and the fourth `trans` says that permutation proofs</a>
  <a id="8474" class="Comment">-- can be chained transitively.</a>

  <a id="8509" class="Comment">-- For example a proof that two lists are a permutation of one</a>
  <a id="8574" class="Comment">-- another can be written as follows:</a>

  <a id="PermutationExplanation.lem₁"></a><a id="8615" href="README.Data.List.html#8615" class="Function">lem₁</a> <a id="8620" class="Symbol">:</a> <a id="8622" class="Number">1</a> <a id="8624" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8626" class="Number">2</a> <a id="8628" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8630" class="Number">3</a> <a id="8632" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8634" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="8637" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="8639" class="Number">3</a> <a id="8641" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8643" class="Number">1</a> <a id="8645" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8647" class="Number">2</a> <a id="8649" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8651" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="8656" href="README.Data.List.html#8615" class="Function">lem₁</a> <a id="8661" class="Symbol">=</a> <a id="8663" href="Data.List.Relation.Binary.Permutation.Inductive.html#857" class="InductiveConstructor">trans</a> <a id="8669" class="Symbol">(</a><a id="8670" href="Data.List.Relation.Binary.Permutation.Inductive.html#745" class="InductiveConstructor">prep</a> <a id="8675" class="Number">1</a> <a id="8677" class="Symbol">(</a><a id="8678" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="8683" class="Number">2</a> <a id="8685" class="Number">3</a> <a id="8687" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a><a id="8691" class="Symbol">))</a> <a id="8694" class="Symbol">(</a><a id="8695" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="8700" class="Number">1</a> <a id="8702" class="Number">3</a> <a id="8704" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a><a id="8708" class="Symbol">)</a>

  <a id="8713" class="Comment">-- In practice it is difficult to parse the constructors in the</a>
  <a id="8779" class="Comment">-- proof above and hence understand why it holds. The</a>
  <a id="8835" class="Comment">-- `PermutationReasoning` module can be used to write this proof</a>
  <a id="8902" class="Comment">-- in a much more readable form:</a>

  <a id="8938" class="Keyword">open</a> <a id="8943" href="Data.List.Relation.Binary.Permutation.Inductive.html#1750" class="Module">PermutationReasoning</a>

  <a id="PermutationExplanation.lem₂"></a><a id="8967" href="README.Data.List.html#8967" class="Function">lem₂</a> <a id="8972" class="Symbol">:</a> <a id="8974" class="Number">1</a> <a id="8976" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8978" class="Number">2</a> <a id="8980" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8982" class="Number">3</a> <a id="8984" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8986" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="8989" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="8991" class="Number">3</a> <a id="8993" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8995" class="Number">1</a> <a id="8997" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8999" class="Number">2</a> <a id="9001" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9003" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="9008" href="README.Data.List.html#8967" class="Function">lem₂</a> <a id="9013" class="Symbol">=</a> <a id="9015" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
    <a id="9025" class="Number">1</a> <a id="9027" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9029" class="Number">2</a> <a id="9031" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9033" class="Number">3</a> <a id="9035" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9037" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9041" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">↭⟨</a> <a id="9044" href="Data.List.Relation.Binary.Permutation.Inductive.html#745" class="InductiveConstructor">prep</a> <a id="9049" class="Number">1</a> <a id="9051" class="Symbol">(</a><a id="9052" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="9057" class="Number">2</a> <a id="9059" class="Number">3</a> <a id="9061" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a><a id="9065" class="Symbol">)</a> <a id="9067" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
    <a id="9073" class="Number">1</a> <a id="9075" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9077" class="Number">3</a> <a id="9079" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9081" class="Number">2</a> <a id="9083" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9085" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9089" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">↭⟨</a> <a id="9092" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="9097" class="Number">1</a> <a id="9099" class="Number">3</a> <a id="9101" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a> <a id="9106" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
    <a id="9112" class="Number">3</a> <a id="9114" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9116" class="Number">1</a> <a id="9118" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9120" class="Number">2</a> <a id="9122" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9124" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9128" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>

  <a id="9133" class="Comment">-- As might be expected, properties of the permutation relation may be</a>
  <a id="9206" class="Comment">-- found in `Data.List.Relation.Binary.Permutation.Inductive.Properties`.</a>

  <a id="9283" class="Keyword">open</a> <a id="9288" class="Keyword">import</a> <a id="9295" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html" class="Module">Data.List.Relation.Binary.Permutation.Inductive.Properties</a>

  <a id="PermutationExplanation.lem₃"></a><a id="9357" href="README.Data.List.html#9357" class="Function">lem₃</a> <a id="9362" class="Symbol">:</a> <a id="9364" class="Symbol">∀</a> <a id="9366" class="Symbol">{</a><a id="9367" href="README.Data.List.html#9367" class="Bound">xs</a> <a id="9370" href="README.Data.List.html#9370" class="Bound">ys</a> <a id="9373" class="Symbol">:</a> <a id="9375" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9380" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="9381" class="Symbol">}</a> <a id="9383" class="Symbol">→</a> <a id="9385" href="README.Data.List.html#9367" class="Bound">xs</a> <a id="9388" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="9390" href="README.Data.List.html#9370" class="Bound">ys</a> <a id="9393" class="Symbol">→</a> <a id="9395" href="Data.List.Base.html#1304" class="Function">map</a> <a id="9399" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="9407" href="README.Data.List.html#9367" class="Bound">xs</a> <a id="9410" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="9412" href="Data.List.Base.html#1304" class="Function">map</a> <a id="9416" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="9424" href="README.Data.List.html#9370" class="Bound">ys</a>
  <a id="9429" href="README.Data.List.html#9357" class="Function">lem₃</a> <a id="9434" class="Symbol">=</a> <a id="9436" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html#2937" class="Function">map⁺</a> <a id="9441" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a>

  <a id="PermutationExplanation.lem₄"></a><a id="9452" href="README.Data.List.html#9452" class="Function">lem₄</a> <a id="9457" class="Symbol">:</a> <a id="9459" href="Algebra.Structures.html#2360" class="Record">IsCommutativeMonoid</a> <a id="9479" class="Symbol">{</a><a id="9480" class="Argument">A</a> <a id="9482" class="Symbol">=</a> <a id="9484" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9489" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="9490" class="Symbol">}</a> <a id="9492" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">_↭_</a> <a id="9496" href="Data.List.Base.html#1570" class="Function Operator">_++_</a> <a id="9501" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="9506" href="README.Data.List.html#9452" class="Function">lem₄</a> <a id="9511" class="Symbol">=</a> <a id="9513" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html#8884" class="Function">++-isCommutativeMonoid</a>

  <a id="9539" class="Comment">-- Note: at the moment permutations have only been formalised for</a>
  <a id="9607" class="Comment">-- propositional equality. Permutations for the other three types of</a>
  <a id="9678" class="Comment">-- equality (decidable propositional, setoid and decidable setoid)</a>
  <a id="9747" class="Comment">-- will hopefully be added in later versions of the library.</a>

<a id="9809" class="Comment">------------------------------------------------------------------------</a>
<a id="9882" class="Comment">-- Other relations</a>

<a id="9902" class="Comment">-- There exist many other binary relations in the</a>
<a id="9952" class="Comment">-- `Data.List.Relation.Binary` folder, including:</a>
<a id="10002" class="Comment">--    1. lexicographic orderings</a>
<a id="10035" class="Comment">--    2. bag/multiset equality</a>
<a id="10066" class="Comment">--    3. the subset relations.</a>
<a id="10097" class="Comment">--    4. the sublist relations</a>

<a id="10129" class="Comment">------------------------------------------------------------------------</a>
<a id="10202" class="Comment">-- 3. Properties of lists</a>
<a id="10228" class="Comment">------------------------------------------------------------------------</a>

<a id="10302" class="Comment">-- Whereas binary relations deal with how two lists relate to one</a>
<a id="10368" class="Comment">-- another, the unary relations in `Data.List.Relation.Unary` are used</a>
<a id="10439" class="Comment">-- to reason about the properties of an individual list.</a>

<a id="10497" class="Comment">------------------------------------------------------------------------</a>
<a id="10570" class="Comment">-- Any</a>

<a id="10578" class="Keyword">module</a> <a id="AnyExplanation"></a><a id="10585" href="README.Data.List.html#10585" class="Module">AnyExplanation</a> <a id="10600" class="Keyword">where</a>

  <a id="10609" class="Comment">-- The predicate `Any` encodes the idea of at least one element of a</a>
  <a id="10680" class="Comment">-- given list satisfying a given property (or more formally a</a>
  <a id="10744" class="Comment">-- predicate, see the `Pred` type in `Relation.Unary`).</a>

  <a id="10803" class="Keyword">open</a> <a id="10808" class="Keyword">import</a> <a id="10815" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="10844" class="Symbol">as</a> <a id="10847" class="Module">Any</a>

  <a id="10854" class="Comment">-- A proof of type Any consists of a sequence of the &quot;there&quot;</a>
  <a id="10917" class="Comment">-- constructors, which says that the element lies in the remainder of</a>
  <a id="10989" class="Comment">-- the list, followed by a single &quot;here&quot; constructor which indicates</a>
  <a id="11060" class="Comment">-- that the head of the list satisfies the predicate and takes a proof</a>
  <a id="11133" class="Comment">-- that it does so.</a>

  <a id="11156" class="Comment">-- For example a proof that a given list of natural numbers contains</a>
  <a id="11227" class="Comment">-- at least one number greater than or equal to 4 can be written as</a>
  <a id="11297" class="Comment">-- follows:</a>

  <a id="AnyExplanation.lem₁"></a><a id="11312" href="README.Data.List.html#11312" class="Function">lem₁</a> <a id="11317" class="Symbol">:</a> <a id="11319" href="Data.List.Relation.Unary.Any.html#1052" class="Datatype">Any</a> <a id="11323" class="Symbol">(</a><a id="11324" class="Number">4</a> <a id="11326" href="Data.Nat.Base.html#966" class="Datatype Operator">≤_</a><a id="11328" class="Symbol">)</a> <a id="11330" class="Symbol">(</a><a id="11331" class="Number">3</a> <a id="11333" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11335" class="Number">5</a> <a id="11337" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11339" class="Number">1</a> <a id="11341" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11343" class="Number">6</a> <a id="11345" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11347" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="11349" class="Symbol">)</a>
  <a id="11353" href="README.Data.List.html#11312" class="Function">lem₁</a> <a id="11358" class="Symbol">=</a> <a id="11360" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11366" class="Symbol">(</a><a id="11367" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a> <a id="11372" href="README.Data.List.html#11391" class="Function">4≤5</a><a id="11375" class="Symbol">)</a>
    <a id="11381" class="Keyword">where</a>
    <a id="11391" href="README.Data.List.html#11391" class="Function">4≤5</a> <a id="11395" class="Symbol">=</a> <a id="11397" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11401" class="Symbol">(</a><a id="11402" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11406" class="Symbol">(</a><a id="11407" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11411" class="Symbol">(</a><a id="11412" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11416" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="11419" class="Symbol">)))</a>

  <a id="11426" class="Comment">-- Note that nothing requires that the proof of `Any` points at the</a>
  <a id="11496" class="Comment">-- first such element in the list. There is therefore an alternative</a>
  <a id="11567" class="Comment">-- proof for the above lemma which points to 6 instead of 5.</a>

  <a id="AnyExplanation.lem₂"></a><a id="11631" href="README.Data.List.html#11631" class="Function">lem₂</a> <a id="11636" class="Symbol">:</a> <a id="11638" href="Data.List.Relation.Unary.Any.html#1052" class="Datatype">Any</a> <a id="11642" class="Symbol">(</a><a id="11643" class="Number">4</a> <a id="11645" href="Data.Nat.Base.html#966" class="Datatype Operator">≤_</a><a id="11647" class="Symbol">)</a> <a id="11649" class="Symbol">(</a><a id="11650" class="Number">3</a> <a id="11652" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11654" class="Number">5</a> <a id="11656" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11658" class="Number">1</a> <a id="11660" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11662" class="Number">6</a> <a id="11664" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11666" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="11668" class="Symbol">)</a>
  <a id="11672" href="README.Data.List.html#11631" class="Function">lem₂</a> <a id="11677" class="Symbol">=</a> <a id="11679" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11685" class="Symbol">(</a><a id="11686" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11692" class="Symbol">(</a><a id="11693" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11699" class="Symbol">(</a><a id="11700" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a> <a id="11705" href="README.Data.List.html#11726" class="Function">4≤6</a><a id="11708" class="Symbol">)))</a>
    <a id="11716" class="Keyword">where</a>
    <a id="11726" href="README.Data.List.html#11726" class="Function">4≤6</a> <a id="11730" class="Symbol">=</a> <a id="11732" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11736" class="Symbol">(</a><a id="11737" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11741" class="Symbol">(</a><a id="11742" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11746" class="Symbol">(</a><a id="11747" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11751" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="11754" class="Symbol">)))</a>

  <a id="11761" class="Comment">-- There also exist various operations over proofs of `Any` whose names</a>
  <a id="11835" class="Comment">-- shadow the corresponding list operation. The standard way of using</a>
  <a id="11907" class="Comment">-- these is to use `as` to name the module:</a>

  <a id="11954" class="Keyword">import</a> <a id="11961" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="11990" class="Symbol">as</a> <a id="11993" class="Module">Any</a>

  <a id="12000" class="Comment">-- and then use the qualified name `Any.map`. For example, map can</a>
  <a id="12069" class="Comment">-- be used to change the predicate of `Any`:</a>

  <a id="12117" class="Keyword">open</a> <a id="12122" class="Keyword">import</a> <a id="12129" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="12149" class="Keyword">using</a> <a id="12155" class="Symbol">(</a><a id="12156" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a><a id="12163" class="Symbol">;</a> <a id="12165" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a><a id="12170" class="Symbol">)</a>

  <a id="AnyExplanation.lem₃"></a><a id="12175" href="README.Data.List.html#12175" class="Function">lem₃</a> <a id="12180" class="Symbol">:</a> <a id="12182" href="Data.List.Relation.Unary.Any.html#1052" class="Datatype">Any</a> <a id="12186" class="Symbol">(</a><a id="12187" class="Number">3</a> <a id="12189" href="Data.Nat.Base.html#966" class="Datatype Operator">≤_</a><a id="12191" class="Symbol">)</a> <a id="12193" class="Symbol">(</a><a id="12194" class="Number">3</a> <a id="12196" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12198" class="Number">5</a> <a id="12200" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12202" class="Number">1</a> <a id="12204" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12206" class="Number">6</a> <a id="12208" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12210" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="12212" class="Symbol">)</a>
  <a id="12216" href="README.Data.List.html#12175" class="Function">lem₃</a> <a id="12221" class="Symbol">=</a> <a id="12223" href="Data.List.Relation.Unary.Any.html#1637" class="Function">Any.map</a> <a id="12231" href="README.Data.List.html#12258" class="Function">4≤x⇒3≤x</a> <a id="12239" href="README.Data.List.html#11631" class="Function">lem₂</a>
    <a id="12248" class="Keyword">where</a>
    <a id="12258" href="README.Data.List.html#12258" class="Function">4≤x⇒3≤x</a> <a id="12266" class="Symbol">:</a> <a id="12268" class="Symbol">∀</a> <a id="12270" class="Symbol">{</a><a id="12271" href="README.Data.List.html#12271" class="Bound">x</a><a id="12272" class="Symbol">}</a> <a id="12274" class="Symbol">→</a> <a id="12276" class="Number">4</a> <a id="12278" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="12280" href="README.Data.List.html#12271" class="Bound">x</a> <a id="12282" class="Symbol">→</a> <a id="12284" class="Number">3</a> <a id="12286" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="12288" href="README.Data.List.html#12271" class="Bound">x</a>
    <a id="12294" href="README.Data.List.html#12258" class="Function">4≤x⇒3≤x</a> <a id="12302" class="Symbol">=</a> <a id="12304" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a> <a id="12312" class="Symbol">(</a><a id="12313" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a> <a id="12319" class="Number">3</a><a id="12320" class="Symbol">)</a>

<a id="12323" class="Comment">------------------------------------------------------------------------</a>
<a id="12396" class="Comment">-- All</a>

<a id="12404" class="Keyword">module</a> <a id="AllExplanation"></a><a id="12411" href="README.Data.List.html#12411" class="Module">AllExplanation</a> <a id="12426" class="Keyword">where</a>

  <a id="12435" class="Comment">-- The dual to `Any` is the predicate `All` which encodes the idea that</a>
  <a id="12509" class="Comment">-- every element in a given list satisfies a given property.</a>

  <a id="12573" class="Keyword">open</a> <a id="12578" class="Keyword">import</a> <a id="12585" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a>

  <a id="12617" class="Comment">-- Proofs for `All` are constructed using exactly the same syntax as</a>
  <a id="12688" class="Comment">-- is used to construct lists (&quot;[]&quot; &amp; &quot;_∷_&quot;). For example to prove</a>
  <a id="12757" class="Comment">-- that every element in a list is less than or equal to one:</a>

  <a id="AllExplanation.lem₁"></a><a id="12822" href="README.Data.List.html#12822" class="Function">lem₁</a> <a id="12827" class="Symbol">:</a> <a id="12829" href="Data.List.Relation.Unary.All.html#1108" class="Datatype">All</a> <a id="12833" class="Symbol">(</a><a id="12834" href="Data.Nat.Base.html#966" class="Datatype Operator">_≤</a> <a id="12837" class="Number">1</a><a id="12838" class="Symbol">)</a> <a id="12840" class="Symbol">(</a><a id="12841" class="Number">1</a> <a id="12843" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12845" class="Number">0</a> <a id="12847" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12849" class="Number">1</a> <a id="12851" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12853" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="12855" class="Symbol">)</a>
  <a id="12859" href="README.Data.List.html#12822" class="Function">lem₁</a> <a id="12864" class="Symbol">=</a> <a id="12866" href="README.Data.List.html#12915" class="Function">1≤1</a> <a id="12870" href="Data.List.Relation.Unary.All.html#1188" class="InductiveConstructor Operator">∷</a> <a id="12872" href="README.Data.List.html#12901" class="Function">0≤1</a> <a id="12876" href="Data.List.Relation.Unary.All.html#1188" class="InductiveConstructor Operator">∷</a> <a id="12878" href="README.Data.List.html#12915" class="Function">1≤1</a> <a id="12882" href="Data.List.Relation.Unary.All.html#1188" class="InductiveConstructor Operator">∷</a> <a id="12884" href="Data.List.Relation.Unary.All.html#1171" class="InductiveConstructor">[]</a>
    <a id="12891" class="Keyword">where</a>
    <a id="12901" href="README.Data.List.html#12901" class="Function">0≤1</a> <a id="12905" class="Symbol">=</a> <a id="12907" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a>
    <a id="12915" href="README.Data.List.html#12915" class="Function">1≤1</a> <a id="12919" class="Symbol">=</a> <a id="12921" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="12925" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a>

  <a id="12932" class="Comment">-- As with `Any`, the module also provides the standard operators</a>
  <a id="13000" class="Comment">-- `map`, `zip` etc. to manipulate proofs for `All`.</a>

  <a id="13056" class="Keyword">import</a> <a id="13063" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="13092" class="Symbol">as</a> <a id="13095" class="Module">All</a>
  <a id="13101" class="Keyword">open</a> <a id="13106" class="Keyword">import</a> <a id="13113" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="13133" class="Keyword">using</a> <a id="13139" class="Symbol">(</a><a id="13140" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a><a id="13147" class="Symbol">;</a> <a id="13149" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a><a id="13154" class="Symbol">)</a>

  <a id="AllExplanation.lem₂"></a><a id="13159" href="README.Data.List.html#13159" class="Function">lem₂</a> <a id="13164" class="Symbol">:</a> <a id="13166" href="Data.List.Relation.Unary.All.html#1108" class="Datatype">All</a> <a id="13170" class="Symbol">(</a><a id="13171" href="Data.Nat.Base.html#966" class="Datatype Operator">_≤</a> <a id="13174" class="Number">2</a><a id="13175" class="Symbol">)</a> <a id="13177" class="Symbol">(</a><a id="13178" class="Number">1</a> <a id="13180" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13182" class="Number">0</a> <a id="13184" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13186" class="Number">1</a> <a id="13188" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13190" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="13192" class="Symbol">)</a>
  <a id="13196" href="README.Data.List.html#13159" class="Function">lem₂</a> <a id="13201" class="Symbol">=</a> <a id="13203" href="Data.List.Relation.Unary.All.html#1866" class="Function">All.map</a> <a id="13211" href="README.Data.List.html#13236" class="Function">≤1⇒≤2</a> <a id="13217" href="README.Data.List.html#12822" class="Function">lem₁</a>
    <a id="13226" class="Keyword">where</a>
    <a id="13236" href="README.Data.List.html#13236" class="Function">≤1⇒≤2</a> <a id="13242" class="Symbol">:</a> <a id="13244" class="Symbol">∀</a> <a id="13246" class="Symbol">{</a><a id="13247" href="README.Data.List.html#13247" class="Bound">x</a><a id="13248" class="Symbol">}</a> <a id="13250" class="Symbol">→</a> <a id="13252" href="README.Data.List.html#13247" class="Bound">x</a> <a id="13254" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="13256" class="Number">1</a> <a id="13258" class="Symbol">→</a> <a id="13260" href="README.Data.List.html#13247" class="Bound">x</a> <a id="13262" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="13264" class="Number">2</a>
    <a id="13270" href="README.Data.List.html#13236" class="Function">≤1⇒≤2</a> <a id="13276" href="README.Data.List.html#13276" class="Bound">x≤1</a> <a id="13280" class="Symbol">=</a> <a id="13282" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a> <a id="13290" href="README.Data.List.html#13276" class="Bound">x≤1</a> <a id="13294" class="Symbol">(</a><a id="13295" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a> <a id="13301" class="Number">1</a><a id="13302" class="Symbol">)</a>

<a id="13305" class="Comment">------------------------------------------------------------------------</a>
<a id="13378" class="Comment">-- Membership</a>

<a id="13393" class="Keyword">module</a> <a id="MembershipExplanation"></a><a id="13400" href="README.Data.List.html#13400" class="Module">MembershipExplanation</a> <a id="13422" class="Keyword">where</a>

  <a id="13431" class="Comment">-- Membership of a list is simply a special case of `Any` where</a>
  <a id="13497" class="Comment">-- `x ∈ xs` is defined as `Any (x ≈_) xs`.</a>

  <a id="13543" class="Comment">-- Just like pointwise equality of lists, the exact membership module</a>
  <a id="13615" class="Comment">-- that should be used depends on whether the equality on the</a>
  <a id="13679" class="Comment">-- underlying elements of the list is i) propositional or setoid-based</a>
  <a id="13752" class="Comment">-- and ii) decidable.</a>

  <a id="13777" class="Keyword">import</a> <a id="13784" href="Data.List.Membership.Setoid.html" class="Module">Data.List.Membership.Setoid</a> <a id="13812" class="Symbol">as</a> <a id="13815" class="Module">SetoidMembership</a>
  <a id="13834" class="Keyword">import</a> <a id="13841" href="Data.List.Membership.DecSetoid.html" class="Module">Data.List.Membership.DecSetoid</a> <a id="13872" class="Symbol">as</a> <a id="13875" class="Module">DecSetoidMembership</a>
  <a id="13897" class="Keyword">import</a> <a id="13904" href="Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="13939" class="Symbol">as</a> <a id="13942" class="Module">PropMembership</a>
  <a id="13959" class="Keyword">import</a> <a id="13966" href="Data.List.Membership.DecPropositional.html" class="Module">Data.List.Membership.DecPropositional</a> <a id="14004" class="Symbol">as</a> <a id="14007" class="Module">DecPropMembership</a>

  <a id="14028" class="Comment">-- For example if we want to reason about membership for `List ℕ`</a>
  <a id="14096" class="Comment">-- then you would use the `DecSetoidMembership` as we use</a>
  <a id="14156" class="Comment">-- propositional equality over `ℕ` and it is also decidable. Therefore</a>
  <a id="14229" class="Comment">-- the module `DecPropMembership` should be opened as follows:</a>

  <a id="14295" class="Keyword">open</a> <a id="14300" href="Data.List.Membership.DecPropositional.html" class="Module">DecPropMembership</a> <a id="14318" href="Data.Nat.Properties.html#2074" class="Function Operator">NatProp._≟_</a>

  <a id="14333" class="Comment">-- As membership is just an instance of `Any` we also need to import</a>
  <a id="14404" class="Comment">-- the constructors `here` and `there`. (See issue #553 on Github for</a>
  <a id="14476" class="Comment">-- why we&#39;re struggling to have `here` and `there` automatically</a>
  <a id="14543" class="Comment">-- re-exported by the membership modules).</a>

  <a id="14589" class="Keyword">open</a> <a id="14594" class="Keyword">import</a> <a id="14601" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="14630" class="Keyword">using</a> <a id="14636" class="Symbol">(</a><a id="14637" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a><a id="14641" class="Symbol">;</a> <a id="14643" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a><a id="14648" class="Symbol">)</a>

  <a id="14653" class="Comment">-- These modules provide the infix notation `_∈_` which can be used</a>
  <a id="14723" class="Comment">-- as follows:</a>

  <a id="MembershipExplanation.lem₁"></a><a id="14741" href="README.Data.List.html#14741" class="Function">lem₁</a> <a id="14746" class="Symbol">:</a> <a id="14748" class="Number">1</a> <a id="14750" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈</a> <a id="14752" class="Number">2</a> <a id="14754" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14756" class="Number">1</a> <a id="14758" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14760" class="Number">3</a> <a id="14762" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14764" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="14769" href="README.Data.List.html#14741" class="Function">lem₁</a> <a id="14774" class="Symbol">=</a> <a id="14776" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="14782" class="Symbol">(</a><a id="14783" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a> <a id="14788" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="14792" class="Symbol">)</a>

  <a id="14797" class="Comment">-- Properties of the membership relation can be found in the following</a>
  <a id="14870" class="Comment">-- two files:</a>

  <a id="14887" class="Keyword">import</a> <a id="14894" href="Data.List.Membership.Setoid.Properties.html" class="Module">Data.List.Membership.Setoid.Properties</a> <a id="14933" class="Symbol">as</a> <a id="14936" class="Module">SetoidProperties</a>
  <a id="14955" class="Keyword">import</a> <a id="14962" href="Data.List.Membership.Propositional.Properties.html" class="Module">Data.List.Membership.Propositional.Properties</a> <a id="15008" class="Symbol">as</a> <a id="15011" class="Module">PropProperties</a>

  <a id="15029" class="Comment">-- As of yet there are no corresponding files for properties of</a>
  <a id="15095" class="Comment">-- membership for decidable versions of setoid and propositional</a>
  <a id="15162" class="Comment">-- equality as we have no properties that only hold when equality is</a>
  <a id="15233" class="Comment">-- decidable.</a>

  <a id="15250" class="Comment">-- These `Properties` modules are NOT parameterised in the same way as</a>
  <a id="15323" class="Comment">-- the main membership modules as some of the properties relate</a>
  <a id="15389" class="Comment">-- membership proofs for lists of different types. For example in the</a>
  <a id="15461" class="Comment">-- following the first `∈` refers to lists of type `List ℕ` whereas</a>
  <a id="15531" class="Comment">-- the second `∈` refers to lists of type `List Char`.</a>

  <a id="15589" class="Keyword">open</a> <a id="15594" href="Data.List.Membership.DecPropositional.html" class="Module">DecPropMembership</a> <a id="15612" href="Data.Char.Properties.html#1063" class="Function Operator">CharProp._≟_</a> <a id="15625" class="Keyword">renaming</a> <a id="15634" class="Symbol">(</a>_∈_ <a id="15639" class="Symbol">to</a> _∈ᶜ_<a id="15646" class="Symbol">)</a>
  <a id="15650" class="Keyword">open</a> <a id="15655" href="Data.List.Membership.Setoid.Properties.html" class="Module">SetoidProperties</a> <a id="15672" class="Keyword">using</a> <a id="15678" class="Symbol">(</a><a id="15679" href="Data.List.Membership.Setoid.Properties.html#3710" class="Function">∈-map⁺</a><a id="15685" class="Symbol">)</a>

  <a id="MembershipExplanation.lem₂"></a><a id="15690" href="README.Data.List.html#15690" class="Function">lem₂</a> <a id="15695" class="Symbol">:</a> <a id="15697" class="Symbol">{</a><a id="15698" href="README.Data.List.html#15698" class="Bound">v</a> <a id="15700" class="Symbol">:</a> <a id="15702" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15703" class="Symbol">}</a> <a id="15705" class="Symbol">{</a><a id="15706" href="README.Data.List.html#15706" class="Bound">xs</a> <a id="15709" class="Symbol">:</a> <a id="15711" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="15716" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15717" class="Symbol">}</a> <a id="15719" class="Symbol">→</a> <a id="15721" href="README.Data.List.html#15698" class="Bound">v</a> <a id="15723" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈</a> <a id="15725" href="README.Data.List.html#15706" class="Bound">xs</a> <a id="15728" class="Symbol">→</a> <a id="15730" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="15738" href="README.Data.List.html#15698" class="Bound">v</a> <a id="15740" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈ᶜ</a> <a id="15743" href="Data.List.Base.html#1304" class="Function">map</a> <a id="15747" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="15755" href="README.Data.List.html#15706" class="Bound">xs</a>
  <a id="15760" href="README.Data.List.html#15690" class="Function">lem₂</a> <a id="15765" class="Symbol">=</a> <a id="15767" href="Data.List.Membership.Setoid.Properties.html#3710" class="Function">∈-map⁺</a> <a id="15774" class="Symbol">(</a><a id="15775" href="Relation.Binary.PropositionalEquality.html#1508" class="Function">setoid</a> <a id="15782" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15783" class="Symbol">)</a> <a id="15785" class="Symbol">(</a><a id="15786" href="Relation.Binary.PropositionalEquality.html#1508" class="Function">setoid</a> <a id="15793" href="Agda.Builtin.Char.html#200" class="Postulate">Char</a><a id="15797" class="Symbol">)</a> <a id="15799" class="Symbol">(</a><a id="15800" href="Relation.Binary.PropositionalEquality.Core.html#1084" class="Function">cong</a> <a id="15805" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a><a id="15812" class="Symbol">)</a>
</pre></body></html>