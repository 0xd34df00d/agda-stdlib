<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.List</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Documentation for the List type</a>
<a id="141" class="Comment">------------------------------------------------------------------------</a>

<a id="215" class="Symbol">{-#</a> <a id="219" class="Keyword">OPTIONS</a> <a id="227" class="Pragma">--warning</a> <a id="237" class="Pragma">noMissingDefinitions</a> <a id="258" class="Symbol">#-}</a>

<a id="263" class="Keyword">module</a> <a id="270" href="README.List.html" class="Module">README.List</a> <a id="282" class="Keyword">where</a>

<a id="289" class="Keyword">open</a> <a id="294" class="Keyword">import</a> <a id="301" href="Algebra.Structures.html" class="Module">Algebra.Structures</a>
<a id="320" class="Keyword">open</a> <a id="325" class="Keyword">import</a> <a id="332" href="Data.Char.html" class="Module">Data.Char</a>
<a id="342" class="Keyword">open</a> <a id="347" class="Keyword">import</a> <a id="354" href="Data.Char.Properties.html" class="Module">Data.Char.Properties</a> <a id="375" class="Symbol">as</a> <a id="378" class="Module">CharProp</a> <a id="387" class="Keyword">hiding</a> <a id="394" class="Symbol">(</a><a id="395" href="Data.Char.Properties.html#1913" class="Function">setoid</a><a id="401" class="Symbol">)</a>
<a id="403" class="Keyword">open</a> <a id="408" class="Keyword">import</a> <a id="415" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="424" class="Keyword">open</a> <a id="429" class="Keyword">import</a> <a id="436" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="456" class="Symbol">as</a> <a id="459" class="Module">NatProp</a>
<a id="467" class="Keyword">open</a> <a id="472" class="Keyword">import</a> <a id="479" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="519" class="Keyword">using</a> <a id="525" class="Symbol">(</a><a id="526" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="529" class="Symbol">;</a> <a id="531" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="535" class="Symbol">;</a> <a id="537" href="Relation.Binary.PropositionalEquality.Core.html#913" class="Function">sym</a><a id="540" class="Symbol">;</a> <a id="542" href="Relation.Binary.PropositionalEquality.Core.html#1084" class="Function">cong</a><a id="546" class="Symbol">;</a> <a id="548" href="Relation.Binary.PropositionalEquality.html#1508" class="Function">setoid</a><a id="554" class="Symbol">)</a>

<a id="557" class="Comment">------------------------------------------------------------------------</a>
<a id="630" class="Comment">-- 1. Basics</a>
<a id="643" class="Comment">------------------------------------------------------------------------</a>
<a id="716" class="Comment">-- The `List` datatype is exported by the following file:</a>

<a id="775" class="Keyword">open</a> <a id="780" class="Keyword">import</a> <a id="787" href="Data.List.html" class="Module">Data.List</a>

<a id="798" class="Keyword">module</a> <a id="Basics"></a><a id="805" href="README.List.html#805" class="Module">Basics</a> <a id="812" class="Keyword">where</a>

  <a id="821" class="Comment">-- Lists are built using the &quot;[]&quot; and &quot;_∷_&quot; constructors.</a>

  <a id="Basics.list₁"></a><a id="882" href="README.List.html#882" class="Function">list₁</a> <a id="888" class="Symbol">:</a> <a id="890" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="895" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
  <a id="899" href="README.List.html#882" class="Function">list₁</a> <a id="905" class="Symbol">=</a> <a id="907" class="Number">3</a> <a id="909" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="911" class="Number">1</a> <a id="913" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="915" class="Number">2</a> <a id="917" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="919" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>

  <a id="925" class="Comment">-- Basic operations over lists are also exported by the same file.</a>

  <a id="Basics.lem₁"></a><a id="995" href="README.List.html#995" class="Function">lem₁</a> <a id="1000" class="Symbol">:</a> <a id="1002" href="Data.List.Base.html#4019" class="Function">sum</a> <a id="1006" href="README.List.html#882" class="Function">list₁</a> <a id="1012" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1014" class="Number">6</a>
  <a id="1018" href="README.List.html#995" class="Function">lem₁</a> <a id="1023" class="Symbol">=</a> <a id="1025" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₂"></a><a id="1033" href="README.List.html#1033" class="Function">lem₂</a> <a id="1038" class="Symbol">:</a> <a id="1040" href="Data.List.Base.html#1299" class="Function">map</a> <a id="1044" class="Symbol">(</a><a id="1045" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+</a> <a id="1048" class="Number">2</a><a id="1049" class="Symbol">)</a> <a id="1051" href="README.List.html#882" class="Function">list₁</a> <a id="1057" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1059" class="Number">5</a> <a id="1061" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1063" class="Number">3</a> <a id="1065" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1067" class="Number">4</a> <a id="1069" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1071" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1076" href="README.List.html#1033" class="Function">lem₂</a> <a id="1081" class="Symbol">=</a> <a id="1083" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₃"></a><a id="1091" href="README.List.html#1091" class="Function">lem₃</a> <a id="1096" class="Symbol">:</a> <a id="1098" href="Data.List.Base.html#6453" class="Function">take</a> <a id="1103" class="Number">2</a> <a id="1105" href="README.List.html#882" class="Function">list₁</a> <a id="1111" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1113" class="Number">3</a> <a id="1115" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1117" class="Number">1</a> <a id="1119" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1121" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1126" href="README.List.html#1091" class="Function">lem₃</a> <a id="1131" class="Symbol">=</a> <a id="1133" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₄"></a><a id="1141" href="README.List.html#1141" class="Function">lem₄</a> <a id="1146" class="Symbol">:</a> <a id="1148" href="Data.List.Base.html#8559" class="Function">reverse</a> <a id="1156" href="README.List.html#882" class="Function">list₁</a> <a id="1162" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1164" class="Number">2</a> <a id="1166" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1168" class="Number">1</a> <a id="1170" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1172" class="Number">3</a> <a id="1174" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1176" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1181" href="README.List.html#1141" class="Function">lem₄</a> <a id="1186" class="Symbol">=</a> <a id="1188" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="Basics.lem₅"></a><a id="1196" href="README.List.html#1196" class="Function">lem₅</a> <a id="1201" class="Symbol">:</a> <a id="1203" href="README.List.html#882" class="Function">list₁</a> <a id="1209" href="Data.List.Base.html#1565" class="Function Operator">++</a> <a id="1212" href="README.List.html#882" class="Function">list₁</a> <a id="1218" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1220" class="Number">3</a> <a id="1222" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1224" class="Number">1</a> <a id="1226" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1228" class="Number">2</a> <a id="1230" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1232" class="Number">3</a> <a id="1234" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1236" class="Number">1</a> <a id="1238" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1240" class="Number">2</a> <a id="1242" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="1244" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="1249" href="README.List.html#1196" class="Function">lem₅</a> <a id="1254" class="Symbol">=</a> <a id="1256" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="1264" class="Comment">-- Various properties of these operations can be found in:</a>

  <a id="1326" class="Keyword">open</a> <a id="1331" class="Keyword">import</a> <a id="1338" href="Data.List.Properties.html" class="Module">Data.List.Properties</a>

  <a id="Basics.lem₆"></a><a id="1362" href="README.List.html#1362" class="Function">lem₆</a> <a id="1367" class="Symbol">:</a> <a id="1369" class="Symbol">∀</a> <a id="1371" href="README.List.html#1371" class="Bound">n</a> <a id="1373" class="Symbol">(</a><a id="1374" href="README.List.html#1374" class="Bound">xs</a> <a id="1377" class="Symbol">:</a> <a id="1379" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1384" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1385" class="Symbol">)</a> <a id="1387" class="Symbol">→</a> <a id="1389" href="Data.List.Base.html#6453" class="Function">take</a> <a id="1394" href="README.List.html#1371" class="Bound">n</a> <a id="1396" href="README.List.html#1374" class="Bound">xs</a> <a id="1399" href="Data.List.Base.html#1565" class="Function Operator">++</a> <a id="1402" href="Data.List.Base.html#6573" class="Function">drop</a> <a id="1407" href="README.List.html#1371" class="Bound">n</a> <a id="1409" href="README.List.html#1374" class="Bound">xs</a> <a id="1412" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1414" href="README.List.html#1374" class="Bound">xs</a>
  <a id="1419" href="README.List.html#1362" class="Function">lem₆</a> <a id="1424" class="Symbol">=</a> <a id="1426" href="Data.List.Properties.html#23214" class="Function">take++drop</a>

  <a id="Basics.lem₇"></a><a id="1440" href="README.List.html#1440" class="Function">lem₇</a> <a id="1445" class="Symbol">:</a> <a id="1447" class="Symbol">∀</a> <a id="1449" class="Symbol">(</a><a id="1450" href="README.List.html#1450" class="Bound">xs</a> <a id="1453" class="Symbol">:</a> <a id="1455" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1460" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1461" class="Symbol">)</a> <a id="1463" class="Symbol">→</a> <a id="1465" href="Data.List.Base.html#8559" class="Function">reverse</a> <a id="1473" class="Symbol">(</a><a id="1474" href="Data.List.Base.html#8559" class="Function">reverse</a> <a id="1482" href="README.List.html#1450" class="Bound">xs</a><a id="1484" class="Symbol">)</a> <a id="1486" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1488" href="README.List.html#1450" class="Bound">xs</a>
  <a id="1493" href="README.List.html#1440" class="Function">lem₇</a> <a id="1498" class="Symbol">=</a> <a id="1500" href="Data.List.Properties.html#27788" class="Function">reverse-involutive</a>

  <a id="Basics.lem₈"></a><a id="1522" href="README.List.html#1522" class="Function">lem₈</a> <a id="1527" class="Symbol">:</a> <a id="1529" class="Symbol">∀</a> <a id="1531" class="Symbol">(</a><a id="1532" href="README.List.html#1532" class="Bound">xs</a> <a id="1535" href="README.List.html#1535" class="Bound">ys</a> <a id="1538" href="README.List.html#1538" class="Bound">zs</a> <a id="1541" class="Symbol">:</a> <a id="1543" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="1548" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="1549" class="Symbol">)</a> <a id="1551" class="Symbol">→</a> <a id="1553" class="Symbol">(</a><a id="1554" href="README.List.html#1532" class="Bound">xs</a> <a id="1557" href="Data.List.Base.html#1565" class="Function Operator">++</a> <a id="1560" href="README.List.html#1535" class="Bound">ys</a><a id="1562" class="Symbol">)</a> <a id="1564" href="Data.List.Base.html#1565" class="Function Operator">++</a> <a id="1567" href="README.List.html#1538" class="Bound">zs</a> <a id="1570" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1572" href="README.List.html#1532" class="Bound">xs</a> <a id="1575" href="Data.List.Base.html#1565" class="Function Operator">++</a> <a id="1578" class="Symbol">(</a><a id="1579" href="README.List.html#1535" class="Bound">ys</a> <a id="1582" href="Data.List.Base.html#1565" class="Function Operator">++</a> <a id="1585" href="README.List.html#1538" class="Bound">zs</a><a id="1587" class="Symbol">)</a>
  <a id="1591" href="README.List.html#1522" class="Function">lem₈</a> <a id="1596" class="Symbol">=</a> <a id="1598" href="Data.List.Properties.html#4770" class="Function">++-assoc</a>

<a id="1608" class="Comment">------------------------------------------------------------------------</a>
<a id="1681" class="Comment">-- 2. Binary relations over lists</a>
<a id="1715" class="Comment">------------------------------------------------------------------------</a>

<a id="1789" class="Comment">-- All binary relations over lists are found in the folder</a>
<a id="1848" class="Comment">-- `Data.List.Relation.Binary`.</a>

<a id="1881" class="Comment">------------------------------------------------------------------------</a>
<a id="1954" class="Comment">-- Pointwise</a>

<a id="1968" class="Keyword">module</a> <a id="PointwiseExplanation"></a><a id="1975" href="README.List.html#1975" class="Module">PointwiseExplanation</a> <a id="1996" class="Keyword">where</a>

  <a id="2005" class="Comment">-- One of the most basic ways to form a binary relation between two</a>
  <a id="2075" class="Comment">-- lists of type `List A`, given a binary relation over `A`, is to say</a>
  <a id="2148" class="Comment">-- that two lists are related if:</a>
  <a id="2184" class="Comment">--   i) the first elements in the lists are related</a>
  <a id="2238" class="Comment">--   ii) the second elements in the lists are related</a>
  <a id="2294" class="Comment">--   iii) the third elements in the lists are related etc.</a>
  <a id="2355" class="Comment">--</a>
  <a id="2360" class="Comment">-- A formalisation of this &quot;pointwise&quot; lifting of a relation to lists</a>
  <a id="2432" class="Comment">-- is found in:</a>

  <a id="2451" class="Keyword">open</a> <a id="2456" class="Keyword">import</a> <a id="2463" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a>

  <a id="2502" class="Comment">-- The same syntax to construct a list (`[]` &amp; `_∷_`) is used to</a>
  <a id="2569" class="Comment">-- construct proofs for the `Pointwise` relation. For example if you</a>
  <a id="2640" class="Comment">-- want to prove that one list is strictly less than another list:</a>

  <a id="PointwiseExplanation.lem₁"></a><a id="2710" href="README.List.html#2710" class="Function">lem₁</a> <a id="2715" class="Symbol">:</a> <a id="2717" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a> <a id="2727" href="Data.Nat.Base.html#1076" class="Function Operator">_&lt;_</a> <a id="2731" class="Symbol">(</a><a id="2732" class="Number">0</a> <a id="2734" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2736" class="Number">2</a> <a id="2738" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2740" class="Number">1</a> <a id="2742" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2744" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2746" class="Symbol">)</a> <a id="2748" class="Symbol">(</a><a id="2749" class="Number">1</a> <a id="2751" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2753" class="Number">4</a> <a id="2755" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2757" class="Number">2</a> <a id="2759" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="2761" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="2763" class="Symbol">)</a>
  <a id="2767" href="README.List.html#2710" class="Function">lem₁</a> <a id="2772" class="Symbol">=</a> <a id="2774" href="README.List.html#2809" class="Function">0&lt;1</a> <a id="2778" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="2780" href="README.List.html#2827" class="Function">2&lt;4</a> <a id="2784" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="2786" href="README.List.html#2857" class="Function">1&lt;2</a> <a id="2790" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="2792" href="Data.List.Relation.Binary.Pointwise.html#1090" class="InductiveConstructor">[]</a>
    <a id="2799" class="Keyword">where</a>
    <a id="2809" href="README.List.html#2809" class="Function">0&lt;1</a> <a id="2813" class="Symbol">=</a> <a id="2815" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2819" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a>
    <a id="2827" href="README.List.html#2827" class="Function">2&lt;4</a> <a id="2831" class="Symbol">=</a> <a id="2833" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2837" class="Symbol">(</a><a id="2838" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2842" class="Symbol">(</a><a id="2843" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2847" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="2850" class="Symbol">))</a>
    <a id="2857" href="README.List.html#2857" class="Function">1&lt;2</a> <a id="2861" class="Symbol">=</a> <a id="2863" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="2867" href="README.List.html#2809" class="Function">0&lt;1</a>

  <a id="2874" class="Comment">-- Lists that are related by `Pointwise` must be of the same length.</a>
  <a id="2945" class="Comment">-- For example:</a>

  <a id="2964" class="Keyword">open</a> <a id="2969" class="Keyword">import</a> <a id="2976" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="2993" class="Keyword">using</a> <a id="2999" class="Symbol">(</a><a id="3000" href="Relation.Nullary.html#500" class="Function Operator">¬_</a><a id="3002" class="Symbol">)</a>

  <a id="PointwiseExplanation.lem₂"></a><a id="3007" href="README.List.html#3007" class="Function">lem₂</a> <a id="3012" class="Symbol">:</a> <a id="3014" href="Relation.Nullary.html#500" class="Function Operator">¬</a> <a id="3016" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a> <a id="3026" href="Data.Nat.Base.html#1076" class="Function Operator">_&lt;_</a> <a id="3030" class="Symbol">(</a><a id="3031" class="Number">0</a> <a id="3033" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3035" class="Number">2</a> <a id="3037" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3039" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3041" class="Symbol">)</a> <a id="3043" class="Symbol">(</a><a id="3044" class="Number">1</a> <a id="3046" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3048" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="3050" class="Symbol">)</a>
  <a id="3054" href="README.List.html#3007" class="Function">lem₂</a> <a id="3059" class="Symbol">(</a><a id="3060" href="README.List.html#3060" class="Bound">0&lt;1</a> <a id="3064" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="3066" class="Symbol">())</a>

<a id="3071" class="Comment">------------------------------------------------------------------------</a>
<a id="3144" class="Comment">-- Equality</a>

<a id="3157" class="Keyword">module</a> <a id="EqualityExplanation"></a><a id="3164" href="README.List.html#3164" class="Module">EqualityExplanation</a> <a id="3184" class="Keyword">where</a>

  <a id="3193" class="Comment">-- There are many different options for what it means for two</a>
  <a id="3257" class="Comment">-- different lists of type `List A` to be &quot;equal&quot;. We will initially</a>
  <a id="3328" class="Comment">-- consider notions of equality that require the list elements to be</a>
  <a id="3399" class="Comment">-- in the same order and later discuss other types of equality.</a>

  <a id="3466" class="Comment">-- The most basic option in the former case is simply to use</a>
  <a id="3529" class="Comment">-- propositional equality `_≡_` over lists:</a>

  <a id="3576" class="Keyword">open</a> <a id="3581" class="Keyword">import</a> <a id="3588" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
    <a id="3630" class="Keyword">using</a> <a id="3636" class="Symbol">(</a><a id="3637" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="3640" class="Symbol">;</a> <a id="3642" href="Relation.Binary.PropositionalEquality.Core.html#913" class="Function">sym</a><a id="3645" class="Symbol">;</a> <a id="3647" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="3651" class="Symbol">)</a>

  <a id="EqualityExplanation.lem₁"></a><a id="3656" href="README.List.html#3656" class="Function">lem₁</a> <a id="3661" class="Symbol">:</a> <a id="3663" class="Number">1</a> <a id="3665" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3667" class="Number">2</a> <a id="3669" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3671" class="Number">3</a> <a id="3673" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3675" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="3678" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3680" class="Number">1</a> <a id="3682" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3684" class="Number">2</a> <a id="3686" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3688" class="Number">3</a> <a id="3690" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3692" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="3697" href="README.List.html#3656" class="Function">lem₁</a> <a id="3702" class="Symbol">=</a> <a id="3704" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

  <a id="3712" class="Comment">-- However propositional equality is only suitable when we want to</a>
  <a id="3781" class="Comment">-- use propositional equality to compare the individual elements.</a>
  <a id="3849" class="Comment">-- Although a contrived example, consider trying to prove the</a>
  <a id="3913" class="Comment">-- equality of two lists of the type `List (ℕ → ℕ)`:</a>

  <a id="EqualityExplanation.lem₂"></a><a id="3969" href="README.List.html#3969" class="Postulate">lem₂</a> <a id="3974" class="Symbol">:</a> <a id="3976" class="Symbol">(λ</a> <a id="3979" href="README.List.html#3979" class="Bound">x</a> <a id="3981" class="Symbol">→</a> <a id="3983" class="Number">2</a> <a id="3985" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="3987" href="README.List.html#3979" class="Bound">x</a> <a id="3989" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="3991" class="Number">2</a><a id="3992" class="Symbol">)</a> <a id="3994" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="3996" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="3999" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4001" class="Symbol">(λ</a> <a id="4004" href="README.List.html#4004" class="Bound">x</a> <a id="4006" class="Symbol">→</a> <a id="4008" class="Number">2</a> <a id="4010" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="4012" class="Symbol">(</a><a id="4013" href="README.List.html#4004" class="Bound">x</a> <a id="4015" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4017" class="Number">1</a><a id="4018" class="Symbol">))</a> <a id="4021" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4023" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>

  <a id="4029" class="Comment">-- In such a case it is impossible to prove the two lists equal with</a>
  <a id="4100" class="Comment">-- refl as the two functions are not propositionally equal. In the</a>
  <a id="4169" class="Comment">-- absence of postulating function extensionality (see README.Axioms),</a>
  <a id="4242" class="Comment">-- the most common definition of function equality is to say that two</a>
  <a id="4314" class="Comment">-- functions are equal if their outputs are always propositionally</a>
  <a id="4383" class="Comment">-- equal for any input. This notion of function equality `_≗_` is</a>
  <a id="4451" class="Comment">-- found in:</a>

  <a id="4467" class="Keyword">open</a> <a id="4472" class="Keyword">import</a> <a id="4479" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="4517" class="Keyword">using</a> <a id="4523" class="Symbol">(</a><a id="4524" href="Relation.Binary.PropositionalEquality.html#2429" class="Function Operator">_≗_</a><a id="4527" class="Symbol">)</a>

  <a id="4532" class="Comment">-- We now want to use the `Pointwise` relation to say that the two</a>
  <a id="4601" class="Comment">-- lists are equal if their elements are pointwise equal with resepct</a>
  <a id="4673" class="Comment">-- to `_≗_`. However instead of using the pointwise module directly</a>
  <a id="4743" class="Comment">-- to write:</a>

  <a id="4759" class="Keyword">open</a> <a id="4764" class="Keyword">import</a> <a id="4771" href="Data.List.Relation.Binary.Pointwise.html" class="Module">Data.List.Relation.Binary.Pointwise</a> <a id="4807" class="Keyword">using</a> <a id="4813" class="Symbol">(</a><a id="4814" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a><a id="4823" class="Symbol">)</a>

  <a id="EqualityExplanation.lem₃"></a><a id="4828" href="README.List.html#4828" class="Postulate">lem₃</a> <a id="4833" class="Symbol">:</a> <a id="4835" href="Data.List.Relation.Binary.Pointwise.html#977" class="Datatype">Pointwise</a> <a id="4845" href="Relation.Binary.PropositionalEquality.html#2429" class="Function Operator">_≗_</a> <a id="4849" class="Symbol">((λ</a> <a id="4853" href="README.List.html#4853" class="Bound">x</a> <a id="4855" class="Symbol">→</a> <a id="4857" href="README.List.html#4853" class="Bound">x</a> <a id="4859" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4861" class="Number">1</a><a id="4862" class="Symbol">)</a> <a id="4864" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4866" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4868" class="Symbol">)</a> <a id="4870" class="Symbol">((λ</a> <a id="4874" href="README.List.html#4874" class="Bound">x</a> <a id="4876" class="Symbol">→</a> <a id="4878" href="README.List.html#4874" class="Bound">x</a> <a id="4880" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="4882" class="Number">2</a> <a id="4884" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="4886" class="Number">1</a><a id="4887" class="Symbol">)</a> <a id="4889" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="4891" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="4893" class="Symbol">)</a>

  <a id="4898" class="Comment">-- the library provides some nicer wrappers and infix notation in the</a>
  <a id="4970" class="Comment">-- folder &quot;Data.List.Relation.Binary.Equality&quot;.</a>

  <a id="5021" class="Comment">-- Within this folder there are four different modules.</a>

  <a id="5080" class="Keyword">import</a> <a id="5087" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">Data.List.Relation.Binary.Equality.Setoid</a>           <a id="5139" class="Symbol">as</a> <a id="5142" class="Module">SetoidEq</a>
  <a id="5153" class="Keyword">import</a> <a id="5160" href="Data.List.Relation.Binary.Equality.DecSetoid.html" class="Module">Data.List.Relation.Binary.Equality.DecSetoid</a>        <a id="5212" class="Symbol">as</a> <a id="5215" class="Module">DecSetoidEq</a>
  <a id="5229" class="Keyword">import</a> <a id="5236" href="Data.List.Relation.Binary.Equality.Propositional.html" class="Module">Data.List.Relation.Binary.Equality.Propositional</a>    <a id="5288" class="Symbol">as</a> <a id="5291" class="Module">PropEq</a>
  <a id="5300" class="Keyword">import</a> <a id="5307" href="Data.List.Relation.Binary.Equality.DecPropositional.html" class="Module">Data.List.Relation.Binary.Equality.DecPropositional</a> <a id="5359" class="Symbol">as</a> <a id="5362" class="Module">DecPropEq</a>

  <a id="5375" class="Comment">-- Which one should be used depends on whether the underlying equality</a>
  <a id="5448" class="Comment">-- over &quot;A&quot; is:</a>
  <a id="5466" class="Comment">--   i)  propositional or setoid-based</a>
  <a id="5507" class="Comment">--   ii) decidable.</a>

  <a id="5530" class="Comment">-- Each of the modules except `PropEq` are designed to be opened with a</a>
  <a id="5604" class="Comment">-- module parameter. This is to avoid having to specify the underlying</a>
  <a id="5677" class="Comment">-- equality relation or the decidability proofs every time you use the</a>
  <a id="5750" class="Comment">-- list equality.</a>

  <a id="5771" class="Comment">-- In our example function equality is not decidable and not propositional</a>
  <a id="5848" class="Comment">-- and so we want to use the `SetoidEq` module. This requires a proof that</a>
  <a id="5925" class="Comment">-- the `_≗_` relation forms a setoid over functions of the type `ℕ → ℕ`.</a>
  <a id="6000" class="Comment">-- This is found in:</a>

  <a id="6024" class="Keyword">open</a> <a id="6029" class="Keyword">import</a> <a id="6036" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="6074" class="Keyword">using</a> <a id="6080" class="Symbol">(</a><a id="6081" href="Relation.Binary.PropositionalEquality.html#2309" class="Function Operator">_→-setoid_</a><a id="6091" class="Symbol">)</a>

  <a id="6096" class="Comment">-- The `SetoidEq` module should therefore be opened as follows:</a>

  <a id="6163" class="Keyword">open</a> <a id="6168" href="Data.List.Relation.Binary.Equality.Setoid.html" class="Module">SetoidEq</a> <a id="6177" class="Symbol">(</a><a id="6178" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="6180" href="Relation.Binary.PropositionalEquality.html#2309" class="Function Operator">→-setoid</a> <a id="6189" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="6190" class="Symbol">)</a>

  <a id="6195" class="Comment">-- All four equality modules provide an infix operator `_≋_` for the</a>
  <a id="6266" class="Comment">-- new equality relation over lists. The type of `lem₃` can therefore</a>
  <a id="6338" class="Comment">-- be rewritten as:</a>

  <a id="EqualityExplanation.lem₄"></a><a id="6361" href="README.List.html#6361" class="Function">lem₄</a> <a id="6366" class="Symbol">:</a> <a id="6368" class="Symbol">(λ</a> <a id="6371" href="README.List.html#6371" class="Bound">x</a> <a id="6373" class="Symbol">→</a> <a id="6375" href="README.List.html#6371" class="Bound">x</a> <a id="6377" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6379" class="Number">1</a><a id="6380" class="Symbol">)</a> <a id="6382" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6384" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="6387" href="Data.List.Relation.Binary.Equality.Setoid.html#792" class="Function Operator">≋</a> <a id="6389" class="Symbol">(λ</a> <a id="6392" href="README.List.html#6392" class="Bound">x</a> <a id="6394" class="Symbol">→</a> <a id="6396" href="README.List.html#6392" class="Bound">x</a> <a id="6398" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6400" class="Number">2</a> <a id="6402" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="6404" class="Number">1</a><a id="6405" class="Symbol">)</a> <a id="6407" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6409" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="6414" href="README.List.html#6361" class="Function">lem₄</a> <a id="6419" class="Symbol">=</a> <a id="6421" href="README.List.html#6452" class="Function">2x+2≗2[x+1]</a> <a id="6433" href="Data.List.Relation.Binary.Pointwise.html#1118" class="InductiveConstructor Operator">∷</a> <a id="6435" href="Data.List.Relation.Binary.Pointwise.html#1090" class="InductiveConstructor">[]</a>
    <a id="6442" class="Keyword">where</a>
    <a id="6452" href="README.List.html#6452" class="Function">2x+2≗2[x+1]</a> <a id="6464" class="Symbol">:</a> <a id="6466" class="Symbol">(λ</a> <a id="6469" href="README.List.html#6469" class="Bound">x</a> <a id="6471" class="Symbol">→</a> <a id="6473" href="README.List.html#6469" class="Bound">x</a> <a id="6475" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6477" class="Number">1</a><a id="6478" class="Symbol">)</a> <a id="6480" href="Relation.Binary.PropositionalEquality.html#2429" class="Function Operator">≗</a> <a id="6482" class="Symbol">(λ</a> <a id="6485" href="README.List.html#6485" class="Bound">x</a> <a id="6487" class="Symbol">→</a> <a id="6489" href="README.List.html#6485" class="Bound">x</a> <a id="6491" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6493" class="Number">2</a> <a id="6495" href="Agda.Builtin.Nat.html#388" class="Primitive Operator">∸</a> <a id="6497" class="Number">1</a><a id="6498" class="Symbol">)</a>
    <a id="6504" href="README.List.html#6452" class="Function">2x+2≗2[x+1]</a> <a id="6516" href="README.List.html#6516" class="Bound">x</a> <a id="6518" class="Symbol">=</a> <a id="6520" href="Relation.Binary.PropositionalEquality.Core.html#913" class="Function">sym</a> <a id="6524" class="Symbol">(</a><a id="6525" href="Data.Nat.Properties.html#37103" class="Function">+-∸-assoc</a> <a id="6535" href="README.List.html#6516" class="Bound">x</a> <a id="6537" class="Symbol">(</a><a id="6538" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="6542" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="6545" class="Symbol">))</a>

  <a id="6551" class="Comment">-- The modules also provide proofs that the `_≋_` relation is a</a>
  <a id="6617" class="Comment">-- setoid in its own right and therefore is reflexive, symmetric,</a>
  <a id="6685" class="Comment">-- transitive:</a>

  <a id="EqualityExplanation.lem₅"></a><a id="6703" href="README.List.html#6703" class="Function">lem₅</a> <a id="6708" class="Symbol">:</a> <a id="6710" class="Symbol">(λ</a> <a id="6713" href="README.List.html#6713" class="Bound">x</a> <a id="6715" class="Symbol">→</a> <a id="6717" class="Number">2</a> <a id="6719" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="6721" href="README.List.html#6713" class="Bound">x</a> <a id="6723" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6725" class="Number">2</a><a id="6726" class="Symbol">)</a> <a id="6728" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6730" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="6733" href="Data.List.Relation.Binary.Equality.Setoid.html#792" class="Function Operator">≋</a> <a id="6735" class="Symbol">(λ</a> <a id="6738" href="README.List.html#6738" class="Bound">x</a> <a id="6740" class="Symbol">→</a> <a id="6742" class="Number">2</a> <a id="6744" href="Agda.Builtin.Nat.html#501" class="Primitive Operator">*</a> <a id="6746" href="README.List.html#6738" class="Bound">x</a> <a id="6748" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="6750" class="Number">2</a><a id="6751" class="Symbol">)</a> <a id="6753" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="6755" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="6760" href="README.List.html#6703" class="Function">lem₅</a> <a id="6765" class="Symbol">=</a> <a id="6767" href="Data.List.Relation.Binary.Equality.Setoid.html#979" class="Function">≋-refl</a>

  <a id="6777" class="Comment">-- If we could prove that `_≗_` forms a `DecSetoid` then we could use</a>
  <a id="6849" class="Comment">-- the module `DecSetoidEq` instead. This exports everything from</a>
  <a id="6917" class="Comment">-- `SetoidEq` as well as the additional proof `_≋?_` that the list</a>
  <a id="6986" class="Comment">-- equality is decidable.</a>

  <a id="7015" class="Comment">-- This pattern of four modules for each of the four different types</a>
  <a id="7086" class="Comment">-- of equality is repeated throughout the library (e.g. see the</a>
  <a id="7152" class="Comment">-- `Membership` subheading below). Note that in this case the modules</a>
  <a id="7224" class="Comment">-- `PropEq` and `DecPropEq` are not very useful as if two lists are</a>
  <a id="7294" class="Comment">-- pointwise propositionally equal they are necessarily</a>
  <a id="7352" class="Comment">-- propositionally equal (and vice-versa). There are proofs of this</a>
  <a id="7422" class="Comment">-- fact exported by `PropEq` and `DecPropEq`. Although, these two</a>
  <a id="7490" class="Comment">-- types of list equality are not very useful in practice, they are</a>
  <a id="7560" class="Comment">-- included for completeness&#39;s sake.</a>

<a id="7598" class="Comment">------------------------------------------------------------------------</a>
<a id="7671" class="Comment">-- Permutations</a>

<a id="7688" class="Keyword">module</a> <a id="PermutationExplanation"></a><a id="7695" href="README.List.html#7695" class="Module">PermutationExplanation</a> <a id="7718" class="Keyword">where</a>

  <a id="7727" class="Comment">-- Alternatively you might consider two lists to be equal if they</a>
  <a id="7795" class="Comment">-- contain the same elements regardless of the order of the elements.</a>
  <a id="7867" class="Comment">-- This is known as either &quot;set equality&quot; or a &quot;permutation&quot;.</a>

  <a id="7932" class="Comment">-- The easiest-to-use formalisation of this relation is found in the</a>
  <a id="8003" class="Comment">-- module:</a>

  <a id="8017" class="Keyword">open</a> <a id="8022" class="Keyword">import</a> <a id="8029" href="Data.List.Relation.Binary.Permutation.Inductive.html" class="Module">Data.List.Relation.Binary.Permutation.Inductive</a>

  <a id="8080" class="Comment">-- The permutation relation is written as `_↭_` and has four</a>
  <a id="8143" class="Comment">-- constructors. The first `refl` says that a list is always</a>
  <a id="8206" class="Comment">-- a permutation of itself, the second `prep` says that if the</a>
  <a id="8271" class="Comment">-- heads of the lists are the same they can be skipped, the third</a>
  <a id="8339" class="Comment">-- `swap` says that the first two elements of the lists can be</a>
  <a id="8404" class="Comment">-- swapped and the fourth `trans` says that permutation proofs</a>
  <a id="8469" class="Comment">-- can be chained transitively.</a>

  <a id="8504" class="Comment">-- For example a proof that two lists are a permutation of one</a>
  <a id="8569" class="Comment">-- another can be written as follows:</a>

  <a id="PermutationExplanation.lem₁"></a><a id="8610" href="README.List.html#8610" class="Function">lem₁</a> <a id="8615" class="Symbol">:</a> <a id="8617" class="Number">1</a> <a id="8619" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8621" class="Number">2</a> <a id="8623" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8625" class="Number">3</a> <a id="8627" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8629" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="8632" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="8634" class="Number">3</a> <a id="8636" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8638" class="Number">1</a> <a id="8640" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8642" class="Number">2</a> <a id="8644" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8646" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="8651" href="README.List.html#8610" class="Function">lem₁</a> <a id="8656" class="Symbol">=</a> <a id="8658" href="Data.List.Relation.Binary.Permutation.Inductive.html#857" class="InductiveConstructor">trans</a> <a id="8664" class="Symbol">(</a><a id="8665" href="Data.List.Relation.Binary.Permutation.Inductive.html#745" class="InductiveConstructor">prep</a> <a id="8670" class="Number">1</a> <a id="8672" class="Symbol">(</a><a id="8673" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="8678" class="Number">2</a> <a id="8680" class="Number">3</a> <a id="8682" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a><a id="8686" class="Symbol">))</a> <a id="8689" class="Symbol">(</a><a id="8690" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="8695" class="Number">1</a> <a id="8697" class="Number">3</a> <a id="8699" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a><a id="8703" class="Symbol">)</a>

  <a id="8708" class="Comment">-- In practice it is difficult to parse the constructors in the</a>
  <a id="8774" class="Comment">-- proof above and hence understand why it holds. The</a>
  <a id="8830" class="Comment">-- `PermutationReasoning` module can be used to write this proof</a>
  <a id="8897" class="Comment">-- in a much more readable form:</a>

  <a id="8933" class="Keyword">open</a> <a id="8938" href="Data.List.Relation.Binary.Permutation.Inductive.html#1750" class="Module">PermutationReasoning</a>

  <a id="PermutationExplanation.lem₂"></a><a id="8962" href="README.List.html#8962" class="Function">lem₂</a> <a id="8967" class="Symbol">:</a> <a id="8969" class="Number">1</a> <a id="8971" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8973" class="Number">2</a> <a id="8975" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8977" class="Number">3</a> <a id="8979" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8981" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a> <a id="8984" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="8986" class="Number">3</a> <a id="8988" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8990" class="Number">1</a> <a id="8992" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8994" class="Number">2</a> <a id="8996" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="8998" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="9003" href="README.List.html#8962" class="Function">lem₂</a> <a id="9008" class="Symbol">=</a> <a id="9010" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
    <a id="9020" class="Number">1</a> <a id="9022" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9024" class="Number">2</a> <a id="9026" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9028" class="Number">3</a> <a id="9030" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9032" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9036" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">↭⟨</a> <a id="9039" href="Data.List.Relation.Binary.Permutation.Inductive.html#745" class="InductiveConstructor">prep</a> <a id="9044" class="Number">1</a> <a id="9046" class="Symbol">(</a><a id="9047" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="9052" class="Number">2</a> <a id="9054" class="Number">3</a> <a id="9056" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a><a id="9060" class="Symbol">)</a> <a id="9062" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
    <a id="9068" class="Number">1</a> <a id="9070" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9072" class="Number">3</a> <a id="9074" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9076" class="Number">2</a> <a id="9078" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9080" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9084" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">↭⟨</a> <a id="9087" href="Data.List.Relation.Binary.Permutation.Inductive.html#797" class="InductiveConstructor">swap</a> <a id="9092" class="Number">1</a> <a id="9094" class="Number">3</a> <a id="9096" href="Data.List.Relation.Binary.Permutation.Inductive.html#711" class="InductiveConstructor">refl</a> <a id="9101" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
    <a id="9107" class="Number">3</a> <a id="9109" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9111" class="Number">1</a> <a id="9113" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9115" class="Number">2</a> <a id="9117" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="9119" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>  <a id="9123" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>

  <a id="9128" class="Comment">-- As might be expected, properties of the permutation relation may be</a>
  <a id="9201" class="Comment">-- found in `Data.List.Relation.Binary.Permutation.Inductive.Properties`.</a>

  <a id="9278" class="Keyword">open</a> <a id="9283" class="Keyword">import</a> <a id="9290" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html" class="Module">Data.List.Relation.Binary.Permutation.Inductive.Properties</a>

  <a id="PermutationExplanation.lem₃"></a><a id="9352" href="README.List.html#9352" class="Function">lem₃</a> <a id="9357" class="Symbol">:</a> <a id="9359" class="Symbol">∀</a> <a id="9361" class="Symbol">{</a><a id="9362" href="README.List.html#9362" class="Bound">xs</a> <a id="9365" href="README.List.html#9365" class="Bound">ys</a> <a id="9368" class="Symbol">:</a> <a id="9370" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9375" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="9376" class="Symbol">}</a> <a id="9378" class="Symbol">→</a> <a id="9380" href="README.List.html#9362" class="Bound">xs</a> <a id="9383" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="9385" href="README.List.html#9365" class="Bound">ys</a> <a id="9388" class="Symbol">→</a> <a id="9390" href="Data.List.Base.html#1299" class="Function">map</a> <a id="9394" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="9402" href="README.List.html#9362" class="Bound">xs</a> <a id="9405" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">↭</a> <a id="9407" href="Data.List.Base.html#1299" class="Function">map</a> <a id="9411" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="9419" href="README.List.html#9365" class="Bound">ys</a>
  <a id="9424" href="README.List.html#9352" class="Function">lem₃</a> <a id="9429" class="Symbol">=</a> <a id="9431" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html#2937" class="Function">map⁺</a> <a id="9436" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a>

  <a id="PermutationExplanation.lem₄"></a><a id="9447" href="README.List.html#9447" class="Function">lem₄</a> <a id="9452" class="Symbol">:</a> <a id="9454" href="Algebra.Structures.html#2360" class="Record">IsCommutativeMonoid</a> <a id="9474" class="Symbol">{</a><a id="9475" class="Argument">A</a> <a id="9477" class="Symbol">=</a> <a id="9479" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="9484" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="9485" class="Symbol">}</a> <a id="9487" href="Data.List.Relation.Binary.Permutation.Inductive.html#682" class="Datatype Operator">_↭_</a> <a id="9491" href="Data.List.Base.html#1565" class="Function Operator">_++_</a> <a id="9496" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="9501" href="README.List.html#9447" class="Function">lem₄</a> <a id="9506" class="Symbol">=</a> <a id="9508" href="Data.List.Relation.Binary.Permutation.Inductive.Properties.html#8884" class="Function">++-isCommutativeMonoid</a>

  <a id="9534" class="Comment">-- Note: at the moment permutations have only been formalised for</a>
  <a id="9602" class="Comment">-- propositional equality. Permutations for the other three types of</a>
  <a id="9673" class="Comment">-- equality (decidable propositional, setoid and decidable setoid)</a>
  <a id="9742" class="Comment">-- will hopefully be added in later versions of the library.</a>

<a id="9804" class="Comment">------------------------------------------------------------------------</a>
<a id="9877" class="Comment">-- Other relations</a>

<a id="9897" class="Comment">-- There exist many other binary relations in the</a>
<a id="9947" class="Comment">-- `Data.List.Relation.Binary` folder, including:</a>
<a id="9997" class="Comment">--    1. lexicographic orderings</a>
<a id="10030" class="Comment">--    2. bag/multiset equality</a>
<a id="10061" class="Comment">--    3. the subset relations.</a>
<a id="10092" class="Comment">--    4. the sublist relations</a>

<a id="10124" class="Comment">------------------------------------------------------------------------</a>
<a id="10197" class="Comment">-- 3. Properties of lists</a>
<a id="10223" class="Comment">------------------------------------------------------------------------</a>

<a id="10297" class="Comment">-- Whereas binary relations deal with how two lists relate to one</a>
<a id="10363" class="Comment">-- another, the unary relations in `Data.List.Relation.Unary` are used</a>
<a id="10434" class="Comment">-- to reason about the properties of an individual list.</a>

<a id="10492" class="Comment">------------------------------------------------------------------------</a>
<a id="10565" class="Comment">-- Any</a>

<a id="10573" class="Keyword">module</a> <a id="AnyExplanation"></a><a id="10580" href="README.List.html#10580" class="Module">AnyExplanation</a> <a id="10595" class="Keyword">where</a>

  <a id="10604" class="Comment">-- The predicate `Any` encodes the idea of at least one element of a</a>
  <a id="10675" class="Comment">-- given list satisfying a given property (or more formally a</a>
  <a id="10739" class="Comment">-- predicate, see the `Pred` type in `Relation.Unary`).</a>

  <a id="10798" class="Keyword">open</a> <a id="10803" class="Keyword">import</a> <a id="10810" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="10839" class="Symbol">as</a> <a id="10842" class="Module">Any</a>

  <a id="10849" class="Comment">-- A proof of type Any consists of a sequence of the &quot;there&quot;</a>
  <a id="10912" class="Comment">-- constructors, which says that the element lies in the remainder of</a>
  <a id="10984" class="Comment">-- the list, followed by a single &quot;here&quot; constructor which indicates</a>
  <a id="11055" class="Comment">-- that the head of the list satisfies the predicate and takes a proof</a>
  <a id="11128" class="Comment">-- that it does so.</a>

  <a id="11151" class="Comment">-- For example a proof that a given list of natural numbers contains</a>
  <a id="11222" class="Comment">-- at least one number greater than or equal to 4 can be written as</a>
  <a id="11292" class="Comment">-- follows:</a>

  <a id="AnyExplanation.lem₁"></a><a id="11307" href="README.List.html#11307" class="Function">lem₁</a> <a id="11312" class="Symbol">:</a> <a id="11314" href="Data.List.Relation.Unary.Any.html#1052" class="Datatype">Any</a> <a id="11318" class="Symbol">(</a><a id="11319" class="Number">4</a> <a id="11321" href="Data.Nat.Base.html#966" class="Datatype Operator">≤_</a><a id="11323" class="Symbol">)</a> <a id="11325" class="Symbol">(</a><a id="11326" class="Number">3</a> <a id="11328" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11330" class="Number">5</a> <a id="11332" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11334" class="Number">1</a> <a id="11336" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11338" class="Number">6</a> <a id="11340" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11342" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="11344" class="Symbol">)</a>
  <a id="11348" href="README.List.html#11307" class="Function">lem₁</a> <a id="11353" class="Symbol">=</a> <a id="11355" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11361" class="Symbol">(</a><a id="11362" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a> <a id="11367" href="README.List.html#11386" class="Function">4≤5</a><a id="11370" class="Symbol">)</a>
    <a id="11376" class="Keyword">where</a>
    <a id="11386" href="README.List.html#11386" class="Function">4≤5</a> <a id="11390" class="Symbol">=</a> <a id="11392" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11396" class="Symbol">(</a><a id="11397" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11401" class="Symbol">(</a><a id="11402" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11406" class="Symbol">(</a><a id="11407" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11411" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="11414" class="Symbol">)))</a>

  <a id="11421" class="Comment">-- Note that nothing requires that the proof of `Any` points at the</a>
  <a id="11491" class="Comment">-- first such element in the list. There is therefore an alternative</a>
  <a id="11562" class="Comment">-- proof for the above lemma which points to 6 instead of 5.</a>

  <a id="AnyExplanation.lem₂"></a><a id="11626" href="README.List.html#11626" class="Function">lem₂</a> <a id="11631" class="Symbol">:</a> <a id="11633" href="Data.List.Relation.Unary.Any.html#1052" class="Datatype">Any</a> <a id="11637" class="Symbol">(</a><a id="11638" class="Number">4</a> <a id="11640" href="Data.Nat.Base.html#966" class="Datatype Operator">≤_</a><a id="11642" class="Symbol">)</a> <a id="11644" class="Symbol">(</a><a id="11645" class="Number">3</a> <a id="11647" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11649" class="Number">5</a> <a id="11651" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11653" class="Number">1</a> <a id="11655" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11657" class="Number">6</a> <a id="11659" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="11661" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="11663" class="Symbol">)</a>
  <a id="11667" href="README.List.html#11626" class="Function">lem₂</a> <a id="11672" class="Symbol">=</a> <a id="11674" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11680" class="Symbol">(</a><a id="11681" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11687" class="Symbol">(</a><a id="11688" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="11694" class="Symbol">(</a><a id="11695" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a> <a id="11700" href="README.List.html#11721" class="Function">4≤6</a><a id="11703" class="Symbol">)))</a>
    <a id="11711" class="Keyword">where</a>
    <a id="11721" href="README.List.html#11721" class="Function">4≤6</a> <a id="11725" class="Symbol">=</a> <a id="11727" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11731" class="Symbol">(</a><a id="11732" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11736" class="Symbol">(</a><a id="11737" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11741" class="Symbol">(</a><a id="11742" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="11746" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a><a id="11749" class="Symbol">)))</a>

  <a id="11756" class="Comment">-- There also exist various operations over proofs of `Any` whose names</a>
  <a id="11830" class="Comment">-- shadow the corresponding list operation. The standard way of using</a>
  <a id="11902" class="Comment">-- these is to use `as` to name the module:</a>

  <a id="11949" class="Keyword">import</a> <a id="11956" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="11985" class="Symbol">as</a> <a id="11988" class="Module">Any</a>

  <a id="11995" class="Comment">-- and then use the qualified name `Any.map`. For example, map can</a>
  <a id="12064" class="Comment">-- be used to change the predicate of `Any`:</a>

  <a id="12112" class="Keyword">open</a> <a id="12117" class="Keyword">import</a> <a id="12124" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="12144" class="Keyword">using</a> <a id="12150" class="Symbol">(</a><a id="12151" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a><a id="12158" class="Symbol">;</a> <a id="12160" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a><a id="12165" class="Symbol">)</a>

  <a id="AnyExplanation.lem₃"></a><a id="12170" href="README.List.html#12170" class="Function">lem₃</a> <a id="12175" class="Symbol">:</a> <a id="12177" href="Data.List.Relation.Unary.Any.html#1052" class="Datatype">Any</a> <a id="12181" class="Symbol">(</a><a id="12182" class="Number">3</a> <a id="12184" href="Data.Nat.Base.html#966" class="Datatype Operator">≤_</a><a id="12186" class="Symbol">)</a> <a id="12188" class="Symbol">(</a><a id="12189" class="Number">3</a> <a id="12191" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12193" class="Number">5</a> <a id="12195" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12197" class="Number">1</a> <a id="12199" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12201" class="Number">6</a> <a id="12203" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12205" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="12207" class="Symbol">)</a>
  <a id="12211" href="README.List.html#12170" class="Function">lem₃</a> <a id="12216" class="Symbol">=</a> <a id="12218" href="Data.List.Relation.Unary.Any.html#1637" class="Function">Any.map</a> <a id="12226" href="README.List.html#12253" class="Function">4≤x⇒3≤x</a> <a id="12234" href="README.List.html#11626" class="Function">lem₂</a>
    <a id="12243" class="Keyword">where</a>
    <a id="12253" href="README.List.html#12253" class="Function">4≤x⇒3≤x</a> <a id="12261" class="Symbol">:</a> <a id="12263" class="Symbol">∀</a> <a id="12265" class="Symbol">{</a><a id="12266" href="README.List.html#12266" class="Bound">x</a><a id="12267" class="Symbol">}</a> <a id="12269" class="Symbol">→</a> <a id="12271" class="Number">4</a> <a id="12273" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="12275" href="README.List.html#12266" class="Bound">x</a> <a id="12277" class="Symbol">→</a> <a id="12279" class="Number">3</a> <a id="12281" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="12283" href="README.List.html#12266" class="Bound">x</a>
    <a id="12289" href="README.List.html#12253" class="Function">4≤x⇒3≤x</a> <a id="12297" class="Symbol">=</a> <a id="12299" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a> <a id="12307" class="Symbol">(</a><a id="12308" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a> <a id="12314" class="Number">3</a><a id="12315" class="Symbol">)</a>

<a id="12318" class="Comment">------------------------------------------------------------------------</a>
<a id="12391" class="Comment">-- All</a>

<a id="12399" class="Keyword">module</a> <a id="AllExplanation"></a><a id="12406" href="README.List.html#12406" class="Module">AllExplanation</a> <a id="12421" class="Keyword">where</a>

  <a id="12430" class="Comment">-- The dual to `Any` is the predicate `All` which encodes the idea that</a>
  <a id="12504" class="Comment">-- every element in a given list satisfies a given property.</a>

  <a id="12568" class="Keyword">open</a> <a id="12573" class="Keyword">import</a> <a id="12580" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a>

  <a id="12612" class="Comment">-- Proofs for `All` are constructed using exactly the same syntax as</a>
  <a id="12683" class="Comment">-- is used to construct lists (&quot;[]&quot; &amp; &quot;_∷_&quot;). For example to prove</a>
  <a id="12752" class="Comment">-- that every element in a list is less than or equal to one:</a>

  <a id="AllExplanation.lem₁"></a><a id="12817" href="README.List.html#12817" class="Function">lem₁</a> <a id="12822" class="Symbol">:</a> <a id="12824" href="Data.List.Relation.Unary.All.html#1108" class="Datatype">All</a> <a id="12828" class="Symbol">(</a><a id="12829" href="Data.Nat.Base.html#966" class="Datatype Operator">_≤</a> <a id="12832" class="Number">1</a><a id="12833" class="Symbol">)</a> <a id="12835" class="Symbol">(</a><a id="12836" class="Number">1</a> <a id="12838" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12840" class="Number">0</a> <a id="12842" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12844" class="Number">1</a> <a id="12846" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="12848" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="12850" class="Symbol">)</a>
  <a id="12854" href="README.List.html#12817" class="Function">lem₁</a> <a id="12859" class="Symbol">=</a> <a id="12861" href="README.List.html#12910" class="Function">1≤1</a> <a id="12865" href="Data.List.Relation.Unary.All.html#1188" class="InductiveConstructor Operator">∷</a> <a id="12867" href="README.List.html#12896" class="Function">0≤1</a> <a id="12871" href="Data.List.Relation.Unary.All.html#1188" class="InductiveConstructor Operator">∷</a> <a id="12873" href="README.List.html#12910" class="Function">1≤1</a> <a id="12877" href="Data.List.Relation.Unary.All.html#1188" class="InductiveConstructor Operator">∷</a> <a id="12879" href="Data.List.Relation.Unary.All.html#1171" class="InductiveConstructor">[]</a>
    <a id="12886" class="Keyword">where</a>
    <a id="12896" href="README.List.html#12896" class="Function">0≤1</a> <a id="12900" class="Symbol">=</a> <a id="12902" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a>
    <a id="12910" href="README.List.html#12910" class="Function">1≤1</a> <a id="12914" class="Symbol">=</a> <a id="12916" href="Data.Nat.Base.html#1031" class="InductiveConstructor">s≤s</a> <a id="12920" href="Data.Nat.Base.html#989" class="InductiveConstructor">z≤n</a>

  <a id="12927" class="Comment">-- As with `Any`, the module also provides the standard operators</a>
  <a id="12995" class="Comment">-- `map`, `zip` etc. to manipulate proofs for `All`.</a>

  <a id="13051" class="Keyword">import</a> <a id="13058" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="13087" class="Symbol">as</a> <a id="13090" class="Module">All</a>
  <a id="13096" class="Keyword">open</a> <a id="13101" class="Keyword">import</a> <a id="13108" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="13128" class="Keyword">using</a> <a id="13134" class="Symbol">(</a><a id="13135" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a><a id="13142" class="Symbol">;</a> <a id="13144" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a><a id="13149" class="Symbol">)</a>

  <a id="AllExplanation.lem₂"></a><a id="13154" href="README.List.html#13154" class="Function">lem₂</a> <a id="13159" class="Symbol">:</a> <a id="13161" href="Data.List.Relation.Unary.All.html#1108" class="Datatype">All</a> <a id="13165" class="Symbol">(</a><a id="13166" href="Data.Nat.Base.html#966" class="Datatype Operator">_≤</a> <a id="13169" class="Number">2</a><a id="13170" class="Symbol">)</a> <a id="13172" class="Symbol">(</a><a id="13173" class="Number">1</a> <a id="13175" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13177" class="Number">0</a> <a id="13179" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13181" class="Number">1</a> <a id="13183" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="13185" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a><a id="13187" class="Symbol">)</a>
  <a id="13191" href="README.List.html#13154" class="Function">lem₂</a> <a id="13196" class="Symbol">=</a> <a id="13198" href="Data.List.Relation.Unary.All.html#1866" class="Function">All.map</a> <a id="13206" href="README.List.html#13231" class="Function">≤1⇒≤2</a> <a id="13212" href="README.List.html#12817" class="Function">lem₁</a>
    <a id="13221" class="Keyword">where</a>
    <a id="13231" href="README.List.html#13231" class="Function">≤1⇒≤2</a> <a id="13237" class="Symbol">:</a> <a id="13239" class="Symbol">∀</a> <a id="13241" class="Symbol">{</a><a id="13242" href="README.List.html#13242" class="Bound">x</a><a id="13243" class="Symbol">}</a> <a id="13245" class="Symbol">→</a> <a id="13247" href="README.List.html#13242" class="Bound">x</a> <a id="13249" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="13251" class="Number">1</a> <a id="13253" class="Symbol">→</a> <a id="13255" href="README.List.html#13242" class="Bound">x</a> <a id="13257" href="Data.Nat.Base.html#966" class="Datatype Operator">≤</a> <a id="13259" class="Number">2</a>
    <a id="13265" href="README.List.html#13231" class="Function">≤1⇒≤2</a> <a id="13271" href="README.List.html#13271" class="Bound">x≤1</a> <a id="13275" class="Symbol">=</a> <a id="13277" href="Data.Nat.Properties.html#3444" class="Function">≤-trans</a> <a id="13285" href="README.List.html#13271" class="Bound">x≤1</a> <a id="13289" class="Symbol">(</a><a id="13290" href="Data.Nat.Properties.html#5563" class="Function">n≤1+n</a> <a id="13296" class="Number">1</a><a id="13297" class="Symbol">)</a>

<a id="13300" class="Comment">------------------------------------------------------------------------</a>
<a id="13373" class="Comment">-- Membership</a>

<a id="13388" class="Keyword">module</a> <a id="MembershipExplanation"></a><a id="13395" href="README.List.html#13395" class="Module">MembershipExplanation</a> <a id="13417" class="Keyword">where</a>

  <a id="13426" class="Comment">-- Membership of a list is simply a special case of `Any` where</a>
  <a id="13492" class="Comment">-- `x ∈ xs` is defined as `Any (x ≈_) xs`.</a>

  <a id="13538" class="Comment">-- Just like pointwise equality of lists, the exact membership module</a>
  <a id="13610" class="Comment">-- that should be used depends on whether the equality on the</a>
  <a id="13674" class="Comment">-- underlying elements of the list is i) propositional or setoid-based</a>
  <a id="13747" class="Comment">-- and ii) decidable.</a>

  <a id="13772" class="Keyword">import</a> <a id="13779" href="Data.List.Membership.Setoid.html" class="Module">Data.List.Membership.Setoid</a> <a id="13807" class="Symbol">as</a> <a id="13810" class="Module">SetoidMembership</a>
  <a id="13829" class="Keyword">import</a> <a id="13836" href="Data.List.Membership.DecSetoid.html" class="Module">Data.List.Membership.DecSetoid</a> <a id="13867" class="Symbol">as</a> <a id="13870" class="Module">DecSetoidMembership</a>
  <a id="13892" class="Keyword">import</a> <a id="13899" href="Data.List.Membership.Propositional.html" class="Module">Data.List.Membership.Propositional</a> <a id="13934" class="Symbol">as</a> <a id="13937" class="Module">PropMembership</a>
  <a id="13954" class="Keyword">import</a> <a id="13961" href="Data.List.Membership.DecPropositional.html" class="Module">Data.List.Membership.DecPropositional</a> <a id="13999" class="Symbol">as</a> <a id="14002" class="Module">DecPropMembership</a>

  <a id="14023" class="Comment">-- For example if we want to reason about membership for `List ℕ`</a>
  <a id="14091" class="Comment">-- then you would use the `DecSetoidMembership` as we use</a>
  <a id="14151" class="Comment">-- propositional equality over `ℕ` and it is also decidable. Therefore</a>
  <a id="14224" class="Comment">-- the module `DecPropMembership` should be opened as follows:</a>

  <a id="14290" class="Keyword">open</a> <a id="14295" href="Data.List.Membership.DecPropositional.html" class="Module">DecPropMembership</a> <a id="14313" href="Data.Nat.Properties.html#2074" class="Function Operator">NatProp._≟_</a>

  <a id="14328" class="Comment">-- As membership is just an instance of `Any` we also need to import</a>
  <a id="14399" class="Comment">-- the constructors `here` and `there`. (See issue #553 on Github for</a>
  <a id="14471" class="Comment">-- why we&#39;re struggling to have `here` and `there` automatically</a>
  <a id="14538" class="Comment">-- re-exported by the membership modules).</a>

  <a id="14584" class="Keyword">open</a> <a id="14589" class="Keyword">import</a> <a id="14596" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="14625" class="Keyword">using</a> <a id="14631" class="Symbol">(</a><a id="14632" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a><a id="14636" class="Symbol">;</a> <a id="14638" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a><a id="14643" class="Symbol">)</a>

  <a id="14648" class="Comment">-- These modules provide the infix notation `_∈_` which can be used</a>
  <a id="14718" class="Comment">-- as follows:</a>

  <a id="MembershipExplanation.lem₁"></a><a id="14736" href="README.List.html#14736" class="Function">lem₁</a> <a id="14741" class="Symbol">:</a> <a id="14743" class="Number">1</a> <a id="14745" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈</a> <a id="14747" class="Number">2</a> <a id="14749" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14751" class="Number">1</a> <a id="14753" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14755" class="Number">3</a> <a id="14757" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">∷</a> <a id="14759" href="Agda.Builtin.List.html#158" class="InductiveConstructor">[]</a>
  <a id="14764" href="README.List.html#14736" class="Function">lem₁</a> <a id="14769" class="Symbol">=</a> <a id="14771" href="Data.List.Relation.Unary.Any.html#1168" class="InductiveConstructor">there</a> <a id="14777" class="Symbol">(</a><a id="14778" href="Data.List.Relation.Unary.Any.html#1115" class="InductiveConstructor">here</a> <a id="14783" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="14787" class="Symbol">)</a>

  <a id="14792" class="Comment">-- Properties of the membership relation can be found in the following</a>
  <a id="14865" class="Comment">-- two files:</a>

  <a id="14882" class="Keyword">import</a> <a id="14889" href="Data.List.Membership.Setoid.Properties.html" class="Module">Data.List.Membership.Setoid.Properties</a> <a id="14928" class="Symbol">as</a> <a id="14931" class="Module">SetoidProperties</a>
  <a id="14950" class="Keyword">import</a> <a id="14957" href="Data.List.Membership.Propositional.Properties.html" class="Module">Data.List.Membership.Propositional.Properties</a> <a id="15003" class="Symbol">as</a> <a id="15006" class="Module">PropProperties</a>

  <a id="15024" class="Comment">-- As of yet there are no corresponding files for properties of</a>
  <a id="15090" class="Comment">-- membership for decidable versions of setoid and propositional</a>
  <a id="15157" class="Comment">-- equality as we have no properties that only hold when equality is</a>
  <a id="15228" class="Comment">-- decidable.</a>

  <a id="15245" class="Comment">-- These `Properties` modules are NOT parameterised in the same way as</a>
  <a id="15318" class="Comment">-- the main membership modules as some of the properties relate</a>
  <a id="15384" class="Comment">-- membership proofs for lists of different types. For example in the</a>
  <a id="15456" class="Comment">-- following the first `∈` refers to lists of type `List ℕ` whereas</a>
  <a id="15526" class="Comment">-- the second `∈` refers to lists of type `List Char`.</a>

  <a id="15584" class="Keyword">open</a> <a id="15589" href="Data.List.Membership.DecPropositional.html" class="Module">DecPropMembership</a> <a id="15607" href="Data.Char.Properties.html#1063" class="Function Operator">CharProp._≟_</a> <a id="15620" class="Keyword">renaming</a> <a id="15629" class="Symbol">(</a>_∈_ <a id="15634" class="Symbol">to</a> _∈ᶜ_<a id="15641" class="Symbol">)</a>
  <a id="15645" class="Keyword">open</a> <a id="15650" href="Data.List.Membership.Setoid.Properties.html" class="Module">SetoidProperties</a> <a id="15667" class="Keyword">using</a> <a id="15673" class="Symbol">(</a><a id="15674" href="Data.List.Membership.Setoid.Properties.html#3710" class="Function">∈-map⁺</a><a id="15680" class="Symbol">)</a>

  <a id="MembershipExplanation.lem₂"></a><a id="15685" href="README.List.html#15685" class="Function">lem₂</a> <a id="15690" class="Symbol">:</a> <a id="15692" class="Symbol">{</a><a id="15693" href="README.List.html#15693" class="Bound">v</a> <a id="15695" class="Symbol">:</a> <a id="15697" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15698" class="Symbol">}</a> <a id="15700" class="Symbol">{</a><a id="15701" href="README.List.html#15701" class="Bound">xs</a> <a id="15704" class="Symbol">:</a> <a id="15706" href="Agda.Builtin.List.html#121" class="Datatype">List</a> <a id="15711" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15712" class="Symbol">}</a> <a id="15714" class="Symbol">→</a> <a id="15716" href="README.List.html#15693" class="Bound">v</a> <a id="15718" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈</a> <a id="15720" href="README.List.html#15701" class="Bound">xs</a> <a id="15723" class="Symbol">→</a> <a id="15725" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="15733" href="README.List.html#15693" class="Bound">v</a> <a id="15735" href="Data.List.Membership.Setoid.html#877" class="Function Operator">∈ᶜ</a> <a id="15738" href="Data.List.Base.html#1299" class="Function">map</a> <a id="15742" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a> <a id="15750" href="README.List.html#15701" class="Bound">xs</a>
  <a id="15755" href="README.List.html#15685" class="Function">lem₂</a> <a id="15760" class="Symbol">=</a> <a id="15762" href="Data.List.Membership.Setoid.Properties.html#3710" class="Function">∈-map⁺</a> <a id="15769" class="Symbol">(</a><a id="15770" href="Relation.Binary.PropositionalEquality.html#1508" class="Function">setoid</a> <a id="15777" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="15778" class="Symbol">)</a> <a id="15780" class="Symbol">(</a><a id="15781" href="Relation.Binary.PropositionalEquality.html#1508" class="Function">setoid</a> <a id="15788" href="Agda.Builtin.Char.html#200" class="Postulate">Char</a><a id="15792" class="Symbol">)</a> <a id="15794" class="Symbol">(</a><a id="15795" href="Relation.Binary.PropositionalEquality.Core.html#1084" class="Function">cong</a> <a id="15800" href="Agda.Builtin.Char.html#439" class="Primitive">fromNat</a><a id="15807" class="Symbol">)</a>
</pre></body></html>