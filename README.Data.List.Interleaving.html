<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>README.Data.List.Interleaving</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Examples showing how the notion of Interleaving can be used</a>
<a id="169" class="Comment">------------------------------------------------------------------------</a>

<a id="243" class="Symbol">{-#</a> <a id="247" class="Keyword">OPTIONS</a> <a id="255" class="Pragma">--without-K</a> <a id="267" class="Pragma">--safe</a> <a id="274" class="Symbol">#-}</a>

<a id="279" class="Keyword">module</a> <a id="286" href="README.Data.List.Interleaving.html" class="Module">README.Data.List.Interleaving</a> <a id="316" class="Keyword">where</a>

<a id="323" class="Keyword">open</a> <a id="328" class="Keyword">import</a> <a id="335" href="Level.html" class="Module">Level</a>
<a id="341" class="Keyword">open</a> <a id="346" class="Keyword">import</a> <a id="353" href="Data.List.Base.html" class="Module">Data.List.Base</a> <a id="368" class="Keyword">hiding</a> <a id="375" class="Symbol">(</a><a id="376" href="Data.List.Base.html#7436" class="Function">filter</a><a id="382" class="Symbol">)</a>
<a id="384" class="Keyword">open</a> <a id="389" class="Keyword">import</a> <a id="396" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a>
<a id="425" class="Keyword">open</a> <a id="430" class="Keyword">import</a> <a id="437" href="Function.html" class="Module">Function</a>
<a id="446" class="Keyword">open</a> <a id="451" class="Keyword">import</a> <a id="458" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>
<a id="475" class="Keyword">open</a> <a id="480" class="Keyword">import</a> <a id="487" href="Relation.Unary.html" class="Module">Relation.Unary</a>

<a id="503" class="Comment">-- In its most general form, `Interleaving` is parametrised by two relations</a>
<a id="580" class="Comment">-- `L` (for Left) and `R` (for Right). Given three lists, `xs`, `ys` and `zs`,</a>
<a id="659" class="Comment">-- a proof of `Interleaving xs ys zs` is essentially a diagram explaining how</a>
<a id="737" class="Comment">-- `zs` can be pulled apart into `xs` and `ys` in a way compatible with `L`</a>
<a id="813" class="Comment">-- and `R`. For instance:</a>

<a id="840" class="Comment">-- xs               zs               ys</a>
<a id="880" class="Comment">--</a>
<a id="883" class="Comment">-- x₁ -- L x₁ z₁ -- z₁</a>
<a id="906" class="Comment">-- x₂ -- L x₂ z₂ -- z₂</a>
<a id="929" class="Comment">--                  z₃ -- R z₃ z₁ -- y₁</a>
<a id="969" class="Comment">-- x₃ -- L x₃ z₄ -- z₄</a>
<a id="992" class="Comment">--                  z₅ -- R z₅ y₂ -- y₂</a>

<a id="1033" class="Keyword">open</a> <a id="1038" class="Keyword">import</a> <a id="1045" href="Data.List.Relation.Ternary.Interleaving.Propositional.html" class="Module">Data.List.Relation.Ternary.Interleaving.Propositional</a>

<a id="1100" class="Comment">-- The special case we will focus on here is the propositional case: both</a>
<a id="1174" class="Comment">-- `L` and ̀R` are propositional equality. Rethinking our previous example,</a>
<a id="1250" class="Comment">-- this gives us the proof that [z₁, ⋯, z₅] can be partitioned into</a>
<a id="1318" class="Comment">-- [z₁, z₂, z₄] on the one hand and [z₃, z₅] in the other.</a>

<a id="1378" class="Comment">-- One possible use case for such a relation is the definition of a very</a>
<a id="1451" class="Comment">-- precise filter function. Provided a decidable predicate `P`, it will</a>
<a id="1523" class="Comment">-- prove not only that the retained values satisfy `P` but that the ones</a>
<a id="1596" class="Comment">-- that didn&#39;t make the cut satisfy the negation of P.</a>

<a id="1652" class="Comment">-- We can make this formal by defining the following record type:</a>

<a id="1719" class="Keyword">infix</a> <a id="1725" class="Number">3</a> <a id="1727" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">_≡_⊎_</a>
<a id="1733" class="Keyword">record</a> <a id="Filter"></a><a id="1740" href="README.Data.List.Interleaving.html#1740" class="Record">Filter</a> <a id="1747" class="Symbol">{</a><a id="1748" href="README.Data.List.Interleaving.html#1748" class="Bound">a</a> <a id="1750" href="README.Data.List.Interleaving.html#1750" class="Bound">p</a><a id="1751" class="Symbol">}</a> <a id="1753" class="Symbol">{</a><a id="1754" href="README.Data.List.Interleaving.html#1754" class="Bound">A</a> <a id="1756" class="Symbol">:</a> <a id="1758" class="PrimitiveType">Set</a> <a id="1762" href="README.Data.List.Interleaving.html#1748" class="Bound">a</a><a id="1763" class="Symbol">}</a> <a id="1765" class="Symbol">(</a><a id="1766" href="README.Data.List.Interleaving.html#1766" class="Bound">P</a> <a id="1768" class="Symbol">:</a> <a id="1770" href="Relation.Unary.html#1101" class="Function">Pred</a> <a id="1775" href="README.Data.List.Interleaving.html#1754" class="Bound">A</a> <a id="1777" href="README.Data.List.Interleaving.html#1750" class="Bound">p</a><a id="1778" class="Symbol">)</a> <a id="1780" class="Symbol">(</a><a id="1781" href="README.Data.List.Interleaving.html#1781" class="Bound">xs</a> <a id="1784" class="Symbol">:</a> <a id="1786" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1791" href="README.Data.List.Interleaving.html#1754" class="Bound">A</a><a id="1792" class="Symbol">)</a> <a id="1794" class="Symbol">:</a> <a id="1796" class="PrimitiveType">Set</a> <a id="1800" class="Symbol">(</a><a id="1801" href="README.Data.List.Interleaving.html#1748" class="Bound">a</a> <a id="1803" href="Agda.Primitive.html#636" class="Primitive Operator">⊔</a> <a id="1805" href="README.Data.List.Interleaving.html#1750" class="Bound">p</a><a id="1806" class="Symbol">)</a> <a id="1808" class="Keyword">where</a>
  <a id="1816" class="Keyword">constructor</a> <a id="_≡_⊎_"></a><a id="1828" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">_≡_⊎_</a>
  <a id="1836" class="Keyword">field</a>
    <a id="1846" class="Comment">-- The result of running filter is two lists:</a>
    <a id="1896" class="Comment">-- * the elements we have kept</a>
    <a id="1931" class="Comment">-- * and the ones we have thrown away</a>
    <a id="1973" class="Comment">-- We leave these implicit: they can be inferred from the rest</a>
    <a id="2040" class="Symbol">{</a><a id="Filter.kept"></a><a id="2041" href="README.Data.List.Interleaving.html#2041" class="Field">kept</a><a id="2045" class="Symbol">}</a>   <a id="2049" class="Symbol">:</a> <a id="2051" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2056" href="README.Data.List.Interleaving.html#1754" class="Bound">A</a>
    <a id="2062" class="Symbol">{</a><a id="Filter.thrown"></a><a id="2063" href="README.Data.List.Interleaving.html#2063" class="Field">thrown</a><a id="2069" class="Symbol">}</a> <a id="2071" class="Symbol">:</a> <a id="2073" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2078" href="README.Data.List.Interleaving.html#1754" class="Bound">A</a>
    <a id="2084" class="Comment">-- There is a way for us to recover the original</a>
    <a id="2137" class="Comment">-- input by interleaving the two lists</a>
    <a id="Filter.cover"></a><a id="2180" href="README.Data.List.Interleaving.html#2180" class="Field">cover</a>    <a id="2189" class="Symbol">:</a> <a id="2191" href="Data.List.Relation.Ternary.Interleaving.Propositional.html#1199" class="Function">Interleaving</a> <a id="2204" href="README.Data.List.Interleaving.html#2041" class="Field">kept</a> <a id="2209" href="README.Data.List.Interleaving.html#2063" class="Field">thrown</a> <a id="2216" href="README.Data.List.Interleaving.html#1781" class="Bound">xs</a>
    <a id="2223" class="Comment">-- Finally, the partition was made according to the predicate</a>
    <a id="Filter.allP"></a><a id="2289" href="README.Data.List.Interleaving.html#2289" class="Field">allP</a>     <a id="2298" class="Symbol">:</a> <a id="2300" href="Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a> <a id="2304" href="README.Data.List.Interleaving.html#1766" class="Bound">P</a> <a id="2306" href="README.Data.List.Interleaving.html#2041" class="Field">kept</a>
    <a id="Filter.all¬P"></a><a id="2315" href="README.Data.List.Interleaving.html#2315" class="Field">all¬P</a>    <a id="2324" class="Symbol">:</a> <a id="2326" href="Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a> <a id="2330" class="Symbol">(</a><a id="2331" href="Relation.Unary.html#4278" class="Function">∁</a> <a id="2333" href="README.Data.List.Interleaving.html#1766" class="Bound">P</a><a id="2334" class="Symbol">)</a> <a id="2336" href="README.Data.List.Interleaving.html#2063" class="Field">thrown</a>

<a id="2344" class="Comment">-- Once we have this type written down, we can write the function.</a>
<a id="2411" class="Comment">-- We use an anonymous module to clean up the function&#39;s type.</a>

<a id="2475" class="Keyword">module</a> <a id="2482" href="README.Data.List.Interleaving.html#2482" class="Module">_</a> <a id="2484" class="Symbol">{</a><a id="2485" href="README.Data.List.Interleaving.html#2485" class="Bound">a</a> <a id="2487" href="README.Data.List.Interleaving.html#2487" class="Bound">p</a><a id="2488" class="Symbol">}</a> <a id="2490" class="Symbol">{</a><a id="2491" href="README.Data.List.Interleaving.html#2491" class="Bound">A</a> <a id="2493" class="Symbol">:</a> <a id="2495" class="PrimitiveType">Set</a> <a id="2499" href="README.Data.List.Interleaving.html#2485" class="Bound">a</a><a id="2500" class="Symbol">}</a> <a id="2502" class="Symbol">{</a><a id="2503" href="README.Data.List.Interleaving.html#2503" class="Bound">P</a> <a id="2505" class="Symbol">:</a> <a id="2507" href="Relation.Unary.html#1101" class="Function">Pred</a> <a id="2512" href="README.Data.List.Interleaving.html#2491" class="Bound">A</a> <a id="2514" href="README.Data.List.Interleaving.html#2487" class="Bound">p</a><a id="2515" class="Symbol">}</a> <a id="2517" class="Symbol">(</a><a id="2518" href="README.Data.List.Interleaving.html#2518" class="Bound">P?</a> <a id="2521" class="Symbol">:</a> <a id="2523" href="Relation.Unary.html#3536" class="Function">Decidable</a> <a id="2533" href="README.Data.List.Interleaving.html#2503" class="Bound">P</a><a id="2534" class="Symbol">)</a> <a id="2536" class="Keyword">where</a>

  <a id="2545" href="README.Data.List.Interleaving.html#2545" class="Function">filter</a> <a id="2552" class="Symbol">:</a> <a id="2554" class="Symbol">∀</a> <a id="2556" href="README.Data.List.Interleaving.html#2556" class="Bound">xs</a> <a id="2559" class="Symbol">→</a> <a id="2561" href="README.Data.List.Interleaving.html#1740" class="Record">Filter</a> <a id="2568" href="README.Data.List.Interleaving.html#2503" class="Bound">P</a> <a id="2570" href="README.Data.List.Interleaving.html#2556" class="Bound">xs</a>
  <a id="2575" class="Comment">-- If the list is empty, we are done.</a>
  <a id="2615" href="README.Data.List.Interleaving.html#2545" class="Function">filter</a> <a id="2622" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="2631" class="Symbol">=</a> <a id="2633" href="Data.List.Relation.Ternary.Interleaving.html#1037" class="InductiveConstructor">[]</a> <a id="2636" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">≡</a> <a id="2638" href="Data.List.Relation.Unary.All.html#1337" class="InductiveConstructor">[]</a> <a id="2641" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">⊎</a> <a id="2643" href="Data.List.Relation.Unary.All.html#1337" class="InductiveConstructor">[]</a>
  <a id="2648" href="README.Data.List.Interleaving.html#2545" class="Function">filter</a> <a id="2655" class="Symbol">(</a><a id="2656" href="README.Data.List.Interleaving.html#2656" class="Bound">x</a> <a id="2658" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2660" href="README.Data.List.Interleaving.html#2660" class="Bound">xs</a><a id="2662" class="Symbol">)</a> <a id="2664" class="Symbol">=</a>
    <a id="2670" class="Comment">-- otherwise we start by running filter on the tail</a>
    <a id="2726" class="Keyword">let</a> <a id="2730" href="README.Data.List.Interleaving.html#2730" class="Bound">xs&#39;</a> <a id="2734" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">≡</a> <a id="2736" href="README.Data.List.Interleaving.html#2736" class="Bound">ps</a> <a id="2739" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">⊎</a> <a id="2741" href="README.Data.List.Interleaving.html#2741" class="Bound">¬ps</a> <a id="2745" class="Symbol">=</a> <a id="2747" href="README.Data.List.Interleaving.html#2545" class="Function">filter</a> <a id="2754" href="README.Data.List.Interleaving.html#2660" class="Bound">xs</a> <a id="2757" class="Keyword">in</a>
    <a id="2764" class="Comment">-- And depending on whether `P` holds of the head,</a>
    <a id="2819" class="Comment">-- we cons it to the `kept` or `thrown` list.</a>
    <a id="2869" href="Function.Base.html#3544" class="Function Operator">case</a> <a id="2874" href="README.Data.List.Interleaving.html#2518" class="Bound">P?</a> <a id="2877" href="README.Data.List.Interleaving.html#2656" class="Bound">x</a> <a id="2879" href="Function.Base.html#3544" class="Function Operator">of</a> <a id="2882" class="Symbol">λ</a> <a id="2884" class="Keyword">where</a> <a id="2890" class="Comment">-- [1]</a>
      <a id="2903" class="Symbol">(</a><a id="2904" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2908" href="README.Data.List.Interleaving.html#2908" class="Bound">p</a><a id="2909" class="Symbol">)</a> <a id="2911" class="Symbol">→</a> <a id="2913" href="Data.List.Relation.Ternary.Interleaving.Propositional.html#1303" class="InductiveConstructor">consˡ</a> <a id="2919" href="README.Data.List.Interleaving.html#2730" class="Bound">xs&#39;</a> <a id="2923" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">≡</a> <a id="2925" href="README.Data.List.Interleaving.html#2908" class="Bound">p</a> <a id="2927" href="Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">∷</a> <a id="2929" href="README.Data.List.Interleaving.html#2736" class="Bound">ps</a> <a id="2932" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">⊎</a>      <a id="2939" href="README.Data.List.Interleaving.html#2741" class="Bound">¬ps</a>
      <a id="2949" class="Symbol">(</a><a id="2950" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2953" href="README.Data.List.Interleaving.html#2953" class="Bound">¬p</a><a id="2955" class="Symbol">)</a> <a id="2957" class="Symbol">→</a> <a id="2959" href="Data.List.Relation.Ternary.Interleaving.Propositional.html#1333" class="InductiveConstructor">consʳ</a> <a id="2965" href="README.Data.List.Interleaving.html#2730" class="Bound">xs&#39;</a> <a id="2969" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">≡</a>     <a id="2975" href="README.Data.List.Interleaving.html#2736" class="Bound">ps</a> <a id="2978" href="README.Data.List.Interleaving.html#1828" class="InductiveConstructor Operator">⊎</a> <a id="2980" href="README.Data.List.Interleaving.html#2953" class="Bound">¬p</a> <a id="2983" href="Data.List.Relation.Unary.All.html#1354" class="InductiveConstructor Operator">∷</a> <a id="2985" href="README.Data.List.Interleaving.html#2741" class="Bound">¬ps</a>



<a id="2992" class="Comment">-- [1] See the following module for explanations of `case_of_` and</a>
<a id="3059" class="Comment">--     pattern-matching lambdas</a>
<a id="3091" class="Keyword">import</a> <a id="3098" href="README.Case.html" class="Module">README.Case</a>
</pre></body></html>